<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/balderdashy/sails-postgresql#readme"

    >sails-postgresql (v0.11.4)</a>
</h1>
<h4>a postgreSQL adapter for Waterline and Sails.js</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.sails-postgresql">module sails-postgresql</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">sails-postgresql.</span>syncable</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.addAttribute">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>addAttribute
            <span class="apidocSignatureSpan">(connectionName, table, attrName, attrDef, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.count">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>count
            <span class="apidocSignatureSpan">(connectionName, table, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.create">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>create
            <span class="apidocSignatureSpan">(connectionName, table, data, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.createEach">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>createEach
            <span class="apidocSignatureSpan">(connectionName, table, records, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.createSchema">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>createSchema
            <span class="apidocSignatureSpan">(connectionName, table, schemaName, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.define">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>define
            <span class="apidocSignatureSpan">(connectionName, table, definition, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.describe">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>describe
            <span class="apidocSignatureSpan">(connectionName, table, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.destroy">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>destroy
            <span class="apidocSignatureSpan">(connectionName, table, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.drop">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>drop
            <span class="apidocSignatureSpan">(connectionName, table, relations, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.find">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>find
            <span class="apidocSignatureSpan">(connectionName, table, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.join">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>join
            <span class="apidocSignatureSpan">(connectionName, table, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.processor">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>processor
            <span class="apidocSignatureSpan">(schema)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.query">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>query
            <span class="apidocSignatureSpan">(connectionName, table, query, data, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.registerConnection">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>registerConnection
            <span class="apidocSignatureSpan">(connection, collections, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.removeAttribute">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>removeAttribute
            <span class="apidocSignatureSpan">(connectionName, table, attrName, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.stream">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>stream
            <span class="apidocSignatureSpan">(connectionName, table, options, stream)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.teardown">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>teardown
            <span class="apidocSignatureSpan">(conn, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.update">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>update
            <span class="apidocSignatureSpan">(connectionName, table, options, data, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sails-postgresql.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sails-postgresql.</span>processor.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sails-postgresql.</span>utils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sails-postgresql.</span>identity</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sails-postgresql.</span>pkFormat</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sails-postgresql.addAttribute">module sails-postgresql.addAttribute</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.addAttribute.addAttribute">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>addAttribute
            <span class="apidocSignatureSpan">(connectionName, table, attrName, attrDef, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sails-postgresql.count">module sails-postgresql.count</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.count.count">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>count
            <span class="apidocSignatureSpan">(connectionName, table, options, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sails-postgresql.create">module sails-postgresql.create</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.create.create">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>create
            <span class="apidocSignatureSpan">(connectionName, table, data, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sails-postgresql.createEach">module sails-postgresql.createEach</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.createEach.createEach">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>createEach
            <span class="apidocSignatureSpan">(connectionName, table, records, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sails-postgresql.createSchema">module sails-postgresql.createSchema</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.createSchema.createSchema">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>createSchema
            <span class="apidocSignatureSpan">(connectionName, table, schemaName, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sails-postgresql.define">module sails-postgresql.define</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.define.define">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>define
            <span class="apidocSignatureSpan">(connectionName, table, definition, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sails-postgresql.describe">module sails-postgresql.describe</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.describe.describe">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>describe
            <span class="apidocSignatureSpan">(connectionName, table, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sails-postgresql.destroy">module sails-postgresql.destroy</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.destroy.destroy">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>destroy
            <span class="apidocSignatureSpan">(connectionName, table, options, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sails-postgresql.drop">module sails-postgresql.drop</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.drop.drop">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>drop
            <span class="apidocSignatureSpan">(connectionName, table, relations, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sails-postgresql.find">module sails-postgresql.find</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.find.find">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>find
            <span class="apidocSignatureSpan">(connectionName, table, options, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sails-postgresql.join">module sails-postgresql.join</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.join.join">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>join
            <span class="apidocSignatureSpan">(connectionName, table, options, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sails-postgresql.processor">module sails-postgresql.processor</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.processor.processor">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>processor
            <span class="apidocSignatureSpan">(schema)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sails-postgresql.processor.prototype">module sails-postgresql.processor.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.processor.prototype.cast">
            function <span class="apidocSignatureSpan">sails-postgresql.processor.prototype.</span>cast
            <span class="apidocSignatureSpan">(table, values)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.processor.prototype.castValue">
            function <span class="apidocSignatureSpan">sails-postgresql.processor.prototype.</span>castValue
            <span class="apidocSignatureSpan">(table, key, value, attributes)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sails-postgresql.query">module sails-postgresql.query</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.query.query">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>query
            <span class="apidocSignatureSpan">(connectionName, table, query, data, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sails-postgresql.registerConnection">module sails-postgresql.registerConnection</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.registerConnection.registerConnection">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>registerConnection
            <span class="apidocSignatureSpan">(connection, collections, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sails-postgresql.removeAttribute">module sails-postgresql.removeAttribute</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.removeAttribute.removeAttribute">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>removeAttribute
            <span class="apidocSignatureSpan">(connectionName, table, attrName, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sails-postgresql.stream">module sails-postgresql.stream</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.stream.stream">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>stream
            <span class="apidocSignatureSpan">(connectionName, table, options, stream)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sails-postgresql.teardown">module sails-postgresql.teardown</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.teardown.teardown">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>teardown
            <span class="apidocSignatureSpan">(conn, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sails-postgresql.update">module sails-postgresql.update</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.update.update">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>update
            <span class="apidocSignatureSpan">(connectionName, table, options, data, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sails-postgresql.utils">module sails-postgresql.utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.utils.buildIndexes">
            function <span class="apidocSignatureSpan">sails-postgresql.utils.</span>buildIndexes
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.utils.buildSchema">
            function <span class="apidocSignatureSpan">sails-postgresql.utils.</span>buildSchema
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.utils.escapeName">
            function <span class="apidocSignatureSpan">sails-postgresql.utils.</span>escapeName
            <span class="apidocSignatureSpan">(name, schema)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.utils.mapAttributes">
            function <span class="apidocSignatureSpan">sails-postgresql.utils.</span>mapAttributes
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.utils.marshalConfig">
            function <span class="apidocSignatureSpan">sails-postgresql.utils.</span>marshalConfig
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.utils.normalizeSchema">
            function <span class="apidocSignatureSpan">sails-postgresql.utils.</span>normalizeSchema
            <span class="apidocSignatureSpan">(schema)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.utils.prepareValue">
            function <span class="apidocSignatureSpan">sails-postgresql.utils.</span>prepareValue
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.utils.sqlTypeCast">
            function <span class="apidocSignatureSpan">sails-postgresql.utils.</span>sqlTypeCast
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.utils.toSqlDate">
            function <span class="apidocSignatureSpan">sails-postgresql.utils.</span>toSqlDate
            <span class="apidocSignatureSpan">(date)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sails-postgresql.utils.</span>object</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sails-postgresql" id="apidoc.module.sails-postgresql">module sails-postgresql</a></h1>




    <h2>
        <a href="#apidoc.element.sails-postgresql.addAttribute" id="apidoc.element.sails-postgresql.addAttribute">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>addAttribute
        <span class="apidocSignatureSpan">(connectionName, table, attrName, attrDef, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addAttribute = function (connectionName, table, attrName, attrDef, cb) {
  spawnConnection(connectionName, function __ADD_ATTRIBUTE__(client, cb) {

    // Escape Table Name
    table = utils.escapeName(table, getSchema(connectionName, table));

    // Setup a Schema Definition
    var attrs = {};
    attrs[attrName] = attrDef;

    var _schema = utils.buildSchema(attrs);

    // Build Query
    var query = &#x27;ALTER TABLE &#x27; + table + &#x27; ADD COLUMN &#x27; + _schema;

    // Run Query
    client.query(query, function __ADD_ATTRIBUTE__(err, result) {
      if(err) return cb(handleQueryError(err));
      cb(null, result.rows);
    });

  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sails-postgresql.count" id="apidoc.element.sails-postgresql.count">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>count
        <span class="apidocSignatureSpan">(connectionName, table, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">count = function (connectionName, table, options, cb) {
  spawnConnection(connectionName, function __COUNT__(client, cb) {

    // Grab Connection Schema
    var schema = {};
    var connectionObject = connections[connectionName];
    var collection = connectionObject.collections[table];
    var tableName = table;

    Object.keys(connectionObject.collections).forEach(function(coll) {
      schema[coll] = connectionObject.collections[coll].schema;
    });

    // Build Query
    var _schema = connectionObject.schema;
    var processor = new Processor(_schema);

    // Mixin WL Next connection overrides to sqlOptions
    var overrides = connectionOverrides[connectionName] || {};
    var _options = _.cloneDeep(sqlOptions);
    if(hop(overrides, &#x27;wlNext&#x27;)) {
      _options.wlNext = overrides.wlNext;
    }

    var sequel = new Sequel(_schema, _options);
    var _query;

    // Build a query for the specific query strategy
    try {
      _query = sequel.count(tableName, options);
    } catch(e) {
      return cb(e);
    }

    client.query(_query.query[0], _query.values[0], function __COUNT__(err, result) {
      if(err) return cb(handleQueryError(err));
      if(!_.isArray(result.rows) || !result.rows.length) {
        return cb(new Error(&#x27;Invalid query, no results returned.&#x27;));
      }

      var count = result.rows[0] &#x26;&#x26; result.rows[0].count;
      return cb(null, Number(count));
    });

  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sails-postgresql.create" id="apidoc.element.sails-postgresql.create">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>create
        <span class="apidocSignatureSpan">(connectionName, table, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (connectionName, table, data, cb) {
  spawnConnection(connectionName, function __CREATE__(client, cb) {

    var connectionObject = connections[connectionName];
    var collection = getCollection(connectionName, table);
    var tableName = table;
    var schemaName = getSchema(collection);

    // Build up a SQL Query
    var schema = connectionObject.schema;
    var processor = new Processor(schema);

    // Mixin WL Next connection overrides to sqlOptions
    var overrides = connectionOverrides[connectionName] || {};
    var options = _.cloneDeep(sqlOptions);
    if(hop(overrides, &#x27;wlNext&#x27;)) {
      options.wlNext = overrides.wlNext;
    }

    var sequel = new Sequel(schema, options);

    var incrementSequences = [];
    var query;

    // Build a query for the specific query strategy
    try {
      query = sequel.create(table, data);
    } catch(e) {
      return cb(e);
    }

    // Loop through all the attributes being inserted and check if a sequence was used
    Object.keys(collection.schema).forEach(function(schemaKey) {
      if(!utils.object.hasOwnProperty(collection.schema[schemaKey], &#x27;autoIncrement&#x27;)) return;
      if(Object.keys(data).indexOf(schemaKey) &#x3c; 0) return;
      incrementSequences.push(schemaKey);
    });

    // Run Query
    client.query(query.query, query.values, function __CREATE__(err, result) {
      if(err) return cb(handleQueryError(err));

      // Cast special values
      var values = processor.cast(tableName, result.rows[0]);

      // Set Sequence value to defined value if needed
      if(incrementSequences.length === 0) return cb(null, values);

      function setSequence(item, next) {
        var sequenceName = &#x22;&#x27;\&#x22;&#x22; + schemaName + &#x27;\&#x22;.\&#x22;&#x27; + tableName + &#x27;_&#x27; + item + &#x27;_seq&#x27; + &#x22;\&#x22;&#x27;&#x22;;
        var sequenceValue = values[item];
        var sequenceQuery = &#x27;SELECT setval(&#x27; + sequenceName + &#x27;, &#x27; + sequenceValue + &#x27;, true)&#x27;;

        client.query(sequenceQuery, function(err, result) {
          if(err) return next(err);
          next();
        });
      }

      async.each(incrementSequences, setSequence, function(err) {
        if(err) return cb(err);
        cb(null, values);
      });

    });

  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sails-postgresql.createEach" id="apidoc.element.sails-postgresql.createEach">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>createEach
        <span class="apidocSignatureSpan">(connectionName, table, records, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createEach = function (connectionName, table, records, cb) {

  // Don&#x27;t bother if there are no records to create.
  if (records.length === 0) {
    return cb();
  }

  spawnConnection(connectionName, function __CREATE_EACH__(client, cb) {

    var connectionObject = connections[connectionName];
    var collection = getCollection(connectionName, table);
    var tableName = table;
    var schemaName = getSchema(collection);

    // Build up a SQL Query
    var schema = connectionObject.schema;
    var processor = new Processor(schema);

    // Mixin WL Next connection overrides to sqlOptions
    var overrides = connectionOverrides[connectionName] || {};
    var options = _.cloneDeep(sqlOptions);
    if(hop(overrides, &#x27;wlNext&#x27;)) {
      options.wlNext = overrides.wlNext;
    }

    var sequel = new Sequel(schema, options);
    var incrementSequences = [];

    // Loop through all the attributes being inserted and check if a sequence was used
    Object.keys(collection.schema).forEach(function(schemaKey) {
      if(!utils.object.hasOwnProperty(collection.schema[schemaKey], &#x27;autoIncrement&#x27;)) return;
      incrementSequences.push({
        key: schemaKey,
        value: 0
      });
    });

    // Collect Query Results
    var results = [];

    // Simple way for now, in the future make this more awesome
    async.each(records, function(data, cb) {

      var query;

      // Build a query for the specific query strategy
      try {
        query = sequel.create(tableName, data);
      } catch(e) {
        return cb(e);
      }

      // Run Query
      client.query(query.query, query.values, function __CREATE_EACH__(err, result) {
        if(err) return cb(handleQueryError(err));

        // Cast special values
        var values = processor.cast(tableName, result.rows[0]);

        results.push(values);
        if(incrementSequences.length === 0) return cb(null, values);

        function checkSequence(item, next) {
          var currentValue  = item.value;
          var sequenceValue = values[item.key];

          if(currentValue &#x3c; sequenceValue) {
            item.value = sequenceValue;
          }
          next();
        }

        async.each(incrementSequences, checkSequence, function(err) {
          if(err) return cb(err);
          cb(null, values);
        });
      });

    }, function(err) {
      if(err) return cb(err);
      if(incrementSequences.length === 0) return cb(null, results);

      function setSequence(item, next) {
        if (sequenceValue === 0) {return next();}
        var sequenceName = &#x22;&#x27;\&#x22;&#x22; + schemaName + &#x27;\&#x22;.\&#x22;&#x27; + tableName + &#x27;_&#x27; + item.key + &#x27;_seq&#x27; + &#x22;\&#x22;&#x27;&#x22;;
        var sequenceValue = item.value;
        var sequenceQuery = &#x27;SELECT setval(&#x27; + sequenceName + &#x27;, &#x27; + sequenceValue + &#x27;, true)&#x27;;

        client.query(sequenceQuery, function(err, result) {
          if(err) return next(err);
          next();
        });
      }

      async.each(incrementSequences, setSequence, function(err) {
        if(err) return cb(err);
        cb(null, results);
      });
    });

  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sails-postgresql.createSchema" id="apidoc.element.sails-postgresql.createSchema">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>createSchema
        <span class="apidocSignatureSpan">(connectionName, table, schemaName, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createSchema = function (connectionName, table, schemaName, cb) {

  if (&#x27;function&#x27; == typeof schemaName) {
    cb = schemaName;
    schemaName = getSchema(connectionName, table);
  }
  if (!schemaName) {
    throw new Error(&#x22;No schemaName specified, and could not determined schemaname for table `&#x22; + table + &#x22;`&#x22;);
  }

  // Build Query
  var query = &#x27;CREATE SCHEMA &#x22;&#x27; + schemaName + &#x27;&#x22;&#x27;;

  spawnConnection(connectionName, function (client, cb) {
    // Run Query
    client.query(query, function (err, result) {
      // If we get a &#x22;duplicate schema&#x22; error, just silently ignore it
      if (err &#x26;&#x26; err.code == &#x27;42P06&#x27;) {return cb();}
      // If we get any other type of error, return it
      if (err) {
        err.type = &#x27;CREATING_SCHEMA&#x27;;
        err.schemaName = schemaName;
        return cb(err);
      }
      // It we get no error, we&#x27;re all good.
      return cb();
    });
  }, cb);

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sails-postgresql.define" id="apidoc.element.sails-postgresql.define">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>define
        <span class="apidocSignatureSpan">(connectionName, table, definition, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">define = function (connectionName, table, definition, cb) {

  // Create a describe method to run after the define.
  // Ensures the define connection is properly closed.
  var describe = function(err, result) {
    if(err) return cb(err);

    // Describe (sets schema)
    adapter.describe(connectionName, table.replace(/[&#x22;&#x27;]/g, &#x22;&#x22;), cb);
  };

  var connectionObject = connections[connectionName];

  spawnConnection(connectionName, function __DEFINE__(client, cb) {

    // Get the schema name if any
    var schemaName = getSchema(connectionName, table);

    // If we&#x27;re being told NOT to create schemas, then skip right to
    // creating the table.
    if (connectionObject.config.createSchemas === false) {return _define();}

    // If the schema name is &#x22;public&#x22;, just finish creating the table
    if (schemaName == &#x27;public&#x27;) {return _define();}

    // If not, attempt to create the schema first.  This will succeed if
    // the schema already exists.
    adapter.createSchema(connectionName, table, schemaName, _define);

    function _define(errCreatingSchema) {

      if (errCreatingSchema) {
        cb(handleQueryError(errCreatingSchema));
      }

      // Escape Table Name
      var tableName = utils.escapeName(table, schemaName);

      // Iterate through each attribute, building a query string
      var _schema = utils.buildSchema(definition);

      // Check for any Index attributes
      var indexes = utils.buildIndexes(definition);

      // Build Query
      var query = &#x27;CREATE TABLE &#x27; + tableName + &#x27; (&#x27; + _schema + &#x27;)&#x27;;

      // Run Query
      client.query(query, function __DEFINE__(err, result) {

        if(err) {
          if (err.code == &#x27;3F000&#x27;) {
            err.table = table;
            err.schemaName = schemaName;
          }
          return cb(handleQueryError(err));
        }

        // Build Indexes
        function buildIndex(name, cb) {

          // Strip slashes from table name, used to namespace index
          var cleanTable = table.replace(/[&#x27;&#x22;]/g, &#x27;&#x27;);

          // Build a query to create a namespaced index tableName_key
          var query = &#x27;CREATE INDEX &#x27; + utils.escapeName(cleanTable + &#x27;_&#x27; + name) + &#x27; on &#x27; + tableName + &#x27; (&#x27; + utils.escapeName
(name) + &#x27;);&#x27;;
          // Run Query
          client.query(query, function(err, result) {
            if(err) return cb(handleQueryError(err));
            cb();
          });
        }

        // Build indexes in series
        async.eachSeries(indexes, buildIndex, cb);
      });

    }

  }, describe);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sails-postgresql.describe" id="apidoc.element.sails-postgresql.describe">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>describe
        <span class="apidocSignatureSpan">(connectionName, table, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">describe = function (connectionName, table, cb) {
  spawnConnection(connectionName, function __DESCRIBE__(client, cb) {

    var connectionObject = connections[connectionName];
    var collection = connectionObject.collections[table];
    var tableName = table;
    var schemaName = getSchema(connectionName, table);

    // Build query to get a bunch of info from the information_schema
    // It&#x27;s not super important to understand it only that it returns the following fields:
    // [Table, #, Column, Type, Null, Constraint, C, consrc, F Key, Default]
    var query = &#x22;SELECT x.nspname || &#x27;.&#x27; || x.relname as \&#x22;Table\&#x22;, x.attnum as \&#x22;#\&#x22;, x.attname as \&#x22;Column\&#x22;, x.\&#x22;Type\&#x22;,&#x22; +
      &#x22; case x.attnotnull when true then &#x27;NOT NULL&#x27; else &#x27;&#x27; end as \&#x22;NULL\&#x22;, r.conname as \&#x22;Constraint\&#x22;, r.contype as \&#x22;C\&#x22;, &#x22; +
      &#x22;r.consrc, fn.nspname || &#x27;.&#x27; || f.relname as \&#x22;F Key\&#x22;, d.adsrc as \&#x22;Default\&#x22; FROM (&#x22; +
      &#x22;SELECT c.oid, a.attrelid, a.attnum, n.nspname, c.relname, a.attname, pg_catalog.format_type(a.atttypid, a.atttypmod) as \&#x22;
Type\&#x22;, &#x22; +
      &#x22;a.attnotnull FROM pg_catalog.pg_attribute a, pg_namespace n, pg_class c WHERE a.attnum &#x3e; 0 AND NOT a.attisdropped AND a.attrelid
 = c.oid &#x22; +
      &#x22;and c.relkind not in (&#x27;S&#x27;,&#x27;v&#x27;) and c.relnamespace = n.oid and n.nspname not in (&#x27;pg_catalog&#x27;,&#x27;pg_toast&#x27;,&#x27;information_schema
&#x27;)) x &#x22; +
      &#x22;left join pg_attrdef d on d.adrelid = x.attrelid and d.adnum = x.attnum &#x22; +
      &#x22;left join pg_constraint r on r.conrelid = x.oid and r.conkey[1] = x.attnum &#x22; +
      &#x22;left join pg_class f on r.confrelid = f.oid &#x22; +
      &#x22;left join pg_namespace fn on f.relnamespace = fn.oid &#x22; +
      &#x22;where x.relname = &#x27;&#x22; + tableName + &#x22;&#x27; and x.nspname = &#x27;&#x22; + schemaName + &#x22;&#x27; order by 1,2;&#x22;;

    // Get Sequences to test if column auto-increments
    var autoIncrementQuery = &#x22;SELECT t.relname as related_table, a.attname as related_column, s.relname as sequence_name &#x22; +
      &#x22;FROM pg_class s JOIN pg_depend d ON d.objid = s.oid JOIN pg_class t ON d.objid = s.oid AND d.refobjid = t.oid &#x22; +
      &#x22;JOIN pg_attribute a ON (d.refobjid, d.refobjsubid) = (a.attrelid, a.attnum) JOIN pg_namespace n ON n.oid = s.relnamespace
 &#x22; +
      &#x22;WHERE s.relkind = &#x27;S&#x27; AND n.nspname = &#x27;&#x22; + schemaName + &#x22;&#x27;;&#x22;;

    // Get Indexes
    var indiciesQuery = &#x22;SELECT n.nspname as \&#x22;Schema\&#x22;, c.relname as \&#x22;Name\&#x22;, CASE c.relkind WHEN &#x27;r&#x27; THEN &#x27;table&#x27; &#x22; +
      &#x22;WHEN &#x27;v&#x27; THEN &#x27;view&#x27; WHEN &#x27;i&#x27; THEN &#x27;index&#x27; WHEN &#x27;S&#x27; THEN &#x27;sequence&#x27; WHEN &#x27;s&#x27; THEN &#x27;special&#x27; WHEN &#x27;f&#x27; THEN &#x22; +
      &#x22;&#x27;foreign table&#x27; END as \&#x22;Type\&#x22;, pg_catalog.pg_get_userbyid(c.relowner) as \&#x22;Owner\&#x22;, c2.relname as \&#x22;Table\&#x22; &#x22; +
      &#x22;FROM pg_catalog.pg_class c LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace &#x22; +
      &#x22;LEFT JOIN pg_catalog.pg_index i ON i.indexrelid = c.oid &#x22; +
      &#x22;LEFT JOIN pg_catalog.pg_class c2 ON i.indrelid = c2.oid &#x22; +
      &#x22;WHERE c.relkind IN (&#x27;i&#x27;,&#x27;&#x27;) AND n.nspname &#x3c;&#x3e; &#x27;pg_catalog&#x27; AND n.nspname &#x3c;&#x3e; &#x27;information_schema&#x27; &#x22; +
      &#x22;AND n.nspname !~ &#x27;^pg_toast&#x27; AND pg_catalog.pg_table_is_visible(c.oid) ORDER BY 1,2;&#x22;;

    // Run Info Query
    client.query(query, function(err, result) {
      if(err) return cb(handleQueryError(err));
      if(result.rows.length === 0) return cb();

      // Run Query to get Auto Incrementing sequences
      client.query(autoIncrementQuery, function(err, aResult) {
        if(err) return cb(handleQueryError(err));

        aResult.rows.forEach(function(row) {
          if(row.related_table !== table) return;

          // Look through query results and see if related_column exists
          result.rows.forEach(function(column) {
            if(column.Column !== row.related_column) return;
            column.autoIncrement = true;
          });
        });

        // Run Query to get Indexed values
        client.query(indiciesQuery, function(err, iResult) {
          if(err) return cb(handleQueryError(err));

          // Loop through indicies and see if any match
          iResult.rows.forEach(function(column) {
            var key = column.Name.split(&#x27;_index_&#x27;)[1];

            // Look through query results and see if key e ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sails-postgresql.destroy" id="apidoc.element.sails-postgresql.destroy">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>destroy
        <span class="apidocSignatureSpan">(connectionName, table, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destroy = function (connectionName, table, options, cb) {
  spawnConnection(connectionName, function __DELETE__(client, cb) {

    var connectionObject = connections[connectionName];
    var collection = connectionObject.collections[table];
    var tableName = table;

    var _schema = connectionObject.schema;

    // Mixin WL Next connection overrides to sqlOptions
    var overrides = connectionOverrides[connectionName] || {};
    var _options = _.cloneDeep(sqlOptions);
    if(hop(overrides, &#x27;wlNext&#x27;)) {
      _options.wlNext = overrides.wlNext;
    }

    var sequel = new Sequel(_schema, _options);
    var query;

    // Build a query for the specific query strategy
    try {
      query = sequel.destroy(tableName, options);
    } catch(e) {
      return cb(e);
    }

    // Run Query
    client.query(query.query, query.values, function __DELETE__(err, result) {
      if(err) return cb(handleQueryError(err));
      cb(null, result.rows);
    });

  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sails-postgresql.drop" id="apidoc.element.sails-postgresql.drop">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>drop
        <span class="apidocSignatureSpan">(connectionName, table, relations, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">drop = function (connectionName, table, relations, cb) {

  if(typeof relations === &#x27;function&#x27;) {
    cb = relations;
    relations = [];
  }

  spawnConnection(connectionName, function __DROP__(client, cb) {

    // Drop any relations
    function dropTable(item, next) {

      var tableName = utils.escapeName(item, getSchema(connectionName, item));

      // Build Query
      var query = &#x27;DROP TABLE &#x27; + tableName + &#x27;;&#x27;;

      // Run Query
      client.query(query, function __DROP__(err, result) {
        if(err) result = null;
        next(null, result);
      });
    }

    async.eachSeries(relations, dropTable, function(err) {
      if(err) return cb(err);
      dropTable(table, cb);
    });

  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sails-postgresql.find" id="apidoc.element.sails-postgresql.find">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>find
        <span class="apidocSignatureSpan">(connectionName, table, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">find = function (connectionName, table, options, cb) {
  spawnConnection(connectionName, function __FIND__(client, cb) {

    // Grab Connection Schema
    var schema = {};
    var connectionObject = connections[connectionName];
    var collection = connectionObject.collections[table];
    var tableName = table;

    Object.keys(connectionObject.collections).forEach(function(coll) {
      schema[coll] = connectionObject.collections[coll].schema;
    });

    // Build Query
    var _schema = connectionObject.schema;
    var processor = new Processor(_schema);

    // Mixin WL Next connection overrides to sqlOptions
    var overrides = connectionOverrides[connectionName] || {};
    var _options = _.cloneDeep(sqlOptions);
    if(hop(overrides, &#x27;wlNext&#x27;)) {
      _options.wlNext = overrides.wlNext;
    }

    var sequel = new Sequel(_schema, _options);
    var _query;

    // Build a query for the specific query strategy
    try {
      _query = sequel.find(tableName, options);
    } catch(e) {
      return cb(e);
    }
    client.query(_query.query[0], _query.values[0], function __FIND__(err, result) {
      if(err) return cb(handleQueryError(err));

      // Cast special values
      var values = [];

      result.rows.forEach(function(row) {
        values.push(processor.cast(tableName, row));
      });

      return cb(null, values);
    });

  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sails-postgresql.join" id="apidoc.element.sails-postgresql.join">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>join
        <span class="apidocSignatureSpan">(connectionName, table, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">join = function (connectionName, table, options, cb) {

  spawnConnection(connectionName, function __FIND__(client, done) {

    // Populate associated records for each parent result
    // (or do them all at once as an optimization, if possible)
    Cursor({

      instructions: options,
      nativeJoins: true,

<span class="apidocCodeCommentSpan">      /**
       * Find some records directly (using only this adapter)
       * from the specified collection.
       *
       * @param  {String}   collectionIdentity
       * @param  {Object}   criteria
       * @param  {Function} _cb
       */
</span>      $find: function (collectionName, criteria, _cb) {
        return adapter.find(conn, collectionIdentity, criteria, _cb, client);
      },

      /**
       * Look up the name of the primary key field
       * for the collection with the specified identity.
       *
       * @param  {String}   collectionIdentity
       * @return {String}
       */
      $getPK: function (collectionName) {
        if (!collectionName) return;
        return _getPK(connectionName, collectionName);
      },

      /**
       * Given a strategy type, build up and execute a SQL query for it.
       *
       * @param {}
       */

      $populateBuffers: function populateBuffers(options, next) {

        var buffers = options.buffers;
        var instructions = options.instructions;

        // Grab the collection by looking into the connection
        var connectionObject = connections[connectionName];
        var collection = connectionObject.collections[table];
        var tableName = table;

        var parentRecords = [];
        var cachedChildren = {};

        // Grab Connection Schema
        var schema = {};

        Object.keys(connectionObject.collections).forEach(function(coll) {
          schema[coll] = connectionObject.collections[coll].schema;
        });

        // Build Query
        var _schema = connectionObject.schema;

        // Mixin WL Next connection overrides to sqlOptions
        var overrides = connectionOverrides[connectionName] || {};
        var _options = _.cloneDeep(sqlOptions);
        if(hop(overrides, &#x27;wlNext&#x27;)) {
          _options.wlNext = overrides.wlNext;
        }

        var sequel = new Sequel(_schema, _options);
        var _query;

        // Build a query for the specific query strategy
        try {
          _query = sequel.find(tableName, instructions);
        } catch(e) {
          return next(e);
        }

        async.auto({

          processParent: function(next) {

            client.query(_query.query[0], _query.values[0], function __FIND__(err, result) {
              if(err) return next(handleQueryError(err));

              parentRecords = result.rows;

              var splitChildren = function(parent, next) {
                var cache = {};

                _.keys(parent).forEach(function(key) {

                  // Check if we can split this on our special alias identifier &#x27;___&#x27; and if
                  // so put the result in the cache
                  var split = key.split(&#x27;___&#x27;);
                  if(split.length &#x3c; 2) return;

                  if(!hop(cache, split[0])) cache[split[0]] = {};
                  cache[split[0]][split[1]] = parent[key];
                  delete parent[key];
                });

                // Combine the local cache into the cachedChildren
                if(_.keys(cache).length &#x3e; 0) {
                  _.keys(cache).forEach(function(pop) {
                    if(!hop(cachedChildren, pop)) cachedChildren[pop] = [];
                    cachedChildren[pop] = cachedChildren[pop].concat(cache[pop]);
                  });
                }

                next();
              };


              // Pull out any aliased child records that have come from a hasFK association
              async.eachSeries(parentRecords, splitChildren, function(err) {
                if(err) return next(err);
                buffers.parents = parentRecords;
                next();
              });
            });
          },

          // Build child buffers.
          // For each instruction, loop through the p ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    attribute.type = val;
  }

  var type = utils.sqlTypeCast(attribute.autoIncrement ? &#x27;SERIAL&#x27; : attribute.type);
  var nullable = attribute.notNull &#x26;&#x26; &#x27;NOT NULL&#x27;;
  var unique = attribute.unique &#x26;&#x26; &#x27;UNIQUE&#x27;;

  return _.compact([ &#x27;&#x22;&#x27; + name + &#x27;&#x22;&#x27;, type, nullable, unique ]).<span class="apidocCodeKeywordSpan
">join</span>(&#x27; &#x27;);
}).join(&#x27;,&#x27;);

var primaryKeys = _.keys(_.pick(obj, function (attribute) {
  return attribute.primaryKey;
}));

var constraints = _.compact([
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sails-postgresql.processor" id="apidoc.element.sails-postgresql.processor">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>processor
        <span class="apidocSignatureSpan">(schema)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Processor(schema) {
  this.schema = _.cloneDeep(schema);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sails-postgresql.query" id="apidoc.element.sails-postgresql.query">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>query
        <span class="apidocSignatureSpan">(connectionName, table, query, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">query = function (connectionName, table, query, data, cb) {

  if (_.isFunction(data)) {
    cb = data;
    data = null;
  }

  spawnConnection(connectionName, function __QUERY__(client, cb) {

    // Run query
    if (data) client.query(query, data, cb);
    else client.query(query, cb);

  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sails-postgresql.registerConnection" id="apidoc.element.sails-postgresql.registerConnection">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>registerConnection
        <span class="apidocSignatureSpan">(connection, collections, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerConnection = function (connection, collections, cb) {

  var self = this;

  if(!connection.identity) return cb(Errors.IdentityMissing);
  if(connections[connection.identity]) return cb(Errors.IdentityDuplicate);

  // Store any connection overrides
  connectionOverrides[connection.identity] = {};

  // Look for the WL Next key
  if(hop(connection, &#x27;wlNext&#x27;)) {
    connectionOverrides[connection.identity].wlNext = _.cloneDeep(connection.wlNext);
  }

  // Build up a schema for this connection that can be used throughout the adapter
  var schema = {};

  _.each(_.keys(collections), function(coll) {
    var collection = collections[coll];
    if(!collection) return;

    var _schema = collection.waterline &#x26;&#x26; collection.waterline.schema &#x26;&#x26; collection.waterline.schema[collection.identity];
    if(!_schema) return;

    // Set defaults to ensure values are set
    if(!_schema.attributes) _schema.attributes = {};
    if(!_schema.tableName) _schema.tableName = coll;

    // If the connection names are&#x27;t the same we don&#x27;t need it in the schema
    if(!_.includes(collections[coll].connection, connection.identity)) {
      return;
    }

    // If this collection has a schema name set, make sure that it&#x27;s passed
    // through to the options for waterline-sequel.
    if(hop(collection, &#x27;meta&#x27;) &#x26;&#x26; hop(collection.meta, &#x27;schemaName&#x27;)) {
      sqlOptions.schemaName[_schema.tableName] = collection.meta.schemaName;
    } else {
      sqlOptions.schemaName[_schema.tableName] = &#x22;public&#x22;;
    }

    // If the tableName is different from the identity, store the tableName in the schema
    var schemaKey = coll;
    if(_schema.tableName != coll) {
      schemaKey = _schema.tableName;
    }

    schema[schemaKey] = _schema;
  });

  // Store the connection
  connections[connection.identity] = {
    config: connection,
    collections: collections,
    schema: schema
  };

  // Always call describe
  async.map(Object.keys(collections), function(colName, cb){
    self.describe(connection.identity, colName, cb);
  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sails-postgresql.removeAttribute" id="apidoc.element.sails-postgresql.removeAttribute">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>removeAttribute
        <span class="apidocSignatureSpan">(connectionName, table, attrName, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeAttribute = function (connectionName, table, attrName, cb) {
  spawnConnection(connectionName, function __REMOVE_ATTRIBUTE__(client, cb) {

    // Escape Table Name
    table = utils.escapeName(table, getSchema(connectionName, table));

    // Build Query
    var query = &#x27;ALTER TABLE &#x27; + table + &#x27; DROP COLUMN &#x22;&#x27; + attrName + &#x27;&#x22; RESTRICT&#x27;;

    // Run Query
    client.query(query, function __REMOVE_ATTRIBUTE__(err, result) {
      if(err) return cb(handleQueryError(err));
      cb(null, result.rows);
    });

  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sails-postgresql.stream" id="apidoc.element.sails-postgresql.stream">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>stream
        <span class="apidocSignatureSpan">(connectionName, table, options, stream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stream = function (connectionName, table, options, stream) {

  var connectionObject = connections[connectionName];
  var collection = connectionObject.collections[table];

  var client = new pg.Client(connectionObject.config);
  client.connect();

  var schema = {};

  Object.keys(connectionObject.collections).forEach(function(coll) {
    schema[coll] = connectionObject.collections[coll].schema;
  });

  // Build Query
  var _schema = collection.schema;
  var queryObj = new Query(_schema, schema);
  var query =queryObj.find(table, options);

  // Run Query
  var dbStream = client.query(query.query, query.values);

  //can stream row results back 1 at a time
  dbStream.on(&#x27;row&#x27;, function(row) {
    stream.write(row);
  });

  dbStream.on(&#x27;error&#x27;, function(err) {
    stream.end(); // End stream
    client.end(); // Close Connection
  });

  //fired after last row is emitted
  dbStream.on(&#x27;end&#x27;, function() {
    stream.end(); // End stream
    client.end(); // Close Connection
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sails-postgresql.teardown" id="apidoc.element.sails-postgresql.teardown">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>teardown
        <span class="apidocSignatureSpan">(conn, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">teardown = function (conn, cb) {
  if (typeof conn == &#x27;function&#x27;) {
    cb = conn;
    conn = null;
  }
  if (conn === null) {
    connections = {};
    return cb();
  }
  if(!connections[conn]) return cb();
  delete connections[conn];
  cb();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sails-postgresql.update" id="apidoc.element.sails-postgresql.update">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>update
        <span class="apidocSignatureSpan">(connectionName, table, options, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">update = function (connectionName, table, options, data, cb) {
  //LIMIT in a postgresql UPDATE command is not valid
  if (hop(options, &#x27;limit&#x27;)) {
    return cb(new Error(&#x27;Your \&#x27;LIMIT &#x27; + options.limit + &#x27;\&#x27; is not allowed in the PostgreSQL UPDATE query.&#x27;));
  }
  spawnConnection(connectionName, function __UPDATE__(client, cb) {

    var connectionObject = connections[connectionName];
    var collection = connectionObject.collections[table];
    var tableName = table;

    var _schema = connectionObject.schema;
    var processor = new Processor(_schema);

    // Mixin WL Next connection overrides to sqlOptions
    var overrides = connectionOverrides[connectionName] || {};
    var _options = _.cloneDeep(sqlOptions);
    if(hop(overrides, &#x27;wlNext&#x27;)) {
      _options.wlNext = overrides.wlNext;
    }

    var sequel = new Sequel(_schema, _options);
    var query;

    // Build a query for the specific query strategy
    try {
      query = sequel.update(tableName, options, data);
    } catch(e) {
      return cb(e);
    }

    // Run Query
    client.query(query.query, query.values, function __UPDATE__(err, result) {
      if(err) return cb(handleQueryError(err));

      // Cast special values
      var values = [];

      result.rows.forEach(function(row) {
        values.push(processor.cast(tableName, row));
      });

      cb(null, values);
    });

  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>












</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sails-postgresql.addAttribute" id="apidoc.module.sails-postgresql.addAttribute">module sails-postgresql.addAttribute</a></h1>


    <h2>
        <a href="#apidoc.element.sails-postgresql.addAttribute.addAttribute" id="apidoc.element.sails-postgresql.addAttribute.addAttribute">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>addAttribute
        <span class="apidocSignatureSpan">(connectionName, table, attrName, attrDef, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addAttribute = function (connectionName, table, attrName, attrDef, cb) {
  spawnConnection(connectionName, function __ADD_ATTRIBUTE__(client, cb) {

    // Escape Table Name
    table = utils.escapeName(table, getSchema(connectionName, table));

    // Setup a Schema Definition
    var attrs = {};
    attrs[attrName] = attrDef;

    var _schema = utils.buildSchema(attrs);

    // Build Query
    var query = &#x27;ALTER TABLE &#x27; + table + &#x27; ADD COLUMN &#x27; + _schema;

    // Run Query
    client.query(query, function __ADD_ATTRIBUTE__(err, result) {
      if(err) return cb(handleQueryError(err));
      cb(null, result.rows);
    });

  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sails-postgresql.count" id="apidoc.module.sails-postgresql.count">module sails-postgresql.count</a></h1>


    <h2>
        <a href="#apidoc.element.sails-postgresql.count.count" id="apidoc.element.sails-postgresql.count.count">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>count
        <span class="apidocSignatureSpan">(connectionName, table, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">count = function (connectionName, table, options, cb) {
  spawnConnection(connectionName, function __COUNT__(client, cb) {

    // Grab Connection Schema
    var schema = {};
    var connectionObject = connections[connectionName];
    var collection = connectionObject.collections[table];
    var tableName = table;

    Object.keys(connectionObject.collections).forEach(function(coll) {
      schema[coll] = connectionObject.collections[coll].schema;
    });

    // Build Query
    var _schema = connectionObject.schema;
    var processor = new Processor(_schema);

    // Mixin WL Next connection overrides to sqlOptions
    var overrides = connectionOverrides[connectionName] || {};
    var _options = _.cloneDeep(sqlOptions);
    if(hop(overrides, &#x27;wlNext&#x27;)) {
      _options.wlNext = overrides.wlNext;
    }

    var sequel = new Sequel(_schema, _options);
    var _query;

    // Build a query for the specific query strategy
    try {
      _query = sequel.count(tableName, options);
    } catch(e) {
      return cb(e);
    }

    client.query(_query.query[0], _query.values[0], function __COUNT__(err, result) {
      if(err) return cb(handleQueryError(err));
      if(!_.isArray(result.rows) || !result.rows.length) {
        return cb(new Error(&#x27;Invalid query, no results returned.&#x27;));
      }

      var count = result.rows[0] &#x26;&#x26; result.rows[0].count;
      return cb(null, Number(count));
    });

  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sails-postgresql.create" id="apidoc.module.sails-postgresql.create">module sails-postgresql.create</a></h1>


    <h2>
        <a href="#apidoc.element.sails-postgresql.create.create" id="apidoc.element.sails-postgresql.create.create">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>create
        <span class="apidocSignatureSpan">(connectionName, table, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (connectionName, table, data, cb) {
  spawnConnection(connectionName, function __CREATE__(client, cb) {

    var connectionObject = connections[connectionName];
    var collection = getCollection(connectionName, table);
    var tableName = table;
    var schemaName = getSchema(collection);

    // Build up a SQL Query
    var schema = connectionObject.schema;
    var processor = new Processor(schema);

    // Mixin WL Next connection overrides to sqlOptions
    var overrides = connectionOverrides[connectionName] || {};
    var options = _.cloneDeep(sqlOptions);
    if(hop(overrides, &#x27;wlNext&#x27;)) {
      options.wlNext = overrides.wlNext;
    }

    var sequel = new Sequel(schema, options);

    var incrementSequences = [];
    var query;

    // Build a query for the specific query strategy
    try {
      query = sequel.create(table, data);
    } catch(e) {
      return cb(e);
    }

    // Loop through all the attributes being inserted and check if a sequence was used
    Object.keys(collection.schema).forEach(function(schemaKey) {
      if(!utils.object.hasOwnProperty(collection.schema[schemaKey], &#x27;autoIncrement&#x27;)) return;
      if(Object.keys(data).indexOf(schemaKey) &#x3c; 0) return;
      incrementSequences.push(schemaKey);
    });

    // Run Query
    client.query(query.query, query.values, function __CREATE__(err, result) {
      if(err) return cb(handleQueryError(err));

      // Cast special values
      var values = processor.cast(tableName, result.rows[0]);

      // Set Sequence value to defined value if needed
      if(incrementSequences.length === 0) return cb(null, values);

      function setSequence(item, next) {
        var sequenceName = &#x22;&#x27;\&#x22;&#x22; + schemaName + &#x27;\&#x22;.\&#x22;&#x27; + tableName + &#x27;_&#x27; + item + &#x27;_seq&#x27; + &#x22;\&#x22;&#x27;&#x22;;
        var sequenceValue = values[item];
        var sequenceQuery = &#x27;SELECT setval(&#x27; + sequenceName + &#x27;, &#x27; + sequenceValue + &#x27;, true)&#x27;;

        client.query(sequenceQuery, function(err, result) {
          if(err) return next(err);
          next();
        });
      }

      async.each(incrementSequences, setSequence, function(err) {
        if(err) return cb(err);
        cb(null, values);
      });

    });

  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sails-postgresql.createEach" id="apidoc.module.sails-postgresql.createEach">module sails-postgresql.createEach</a></h1>


    <h2>
        <a href="#apidoc.element.sails-postgresql.createEach.createEach" id="apidoc.element.sails-postgresql.createEach.createEach">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>createEach
        <span class="apidocSignatureSpan">(connectionName, table, records, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createEach = function (connectionName, table, records, cb) {

  // Don&#x27;t bother if there are no records to create.
  if (records.length === 0) {
    return cb();
  }

  spawnConnection(connectionName, function __CREATE_EACH__(client, cb) {

    var connectionObject = connections[connectionName];
    var collection = getCollection(connectionName, table);
    var tableName = table;
    var schemaName = getSchema(collection);

    // Build up a SQL Query
    var schema = connectionObject.schema;
    var processor = new Processor(schema);

    // Mixin WL Next connection overrides to sqlOptions
    var overrides = connectionOverrides[connectionName] || {};
    var options = _.cloneDeep(sqlOptions);
    if(hop(overrides, &#x27;wlNext&#x27;)) {
      options.wlNext = overrides.wlNext;
    }

    var sequel = new Sequel(schema, options);
    var incrementSequences = [];

    // Loop through all the attributes being inserted and check if a sequence was used
    Object.keys(collection.schema).forEach(function(schemaKey) {
      if(!utils.object.hasOwnProperty(collection.schema[schemaKey], &#x27;autoIncrement&#x27;)) return;
      incrementSequences.push({
        key: schemaKey,
        value: 0
      });
    });

    // Collect Query Results
    var results = [];

    // Simple way for now, in the future make this more awesome
    async.each(records, function(data, cb) {

      var query;

      // Build a query for the specific query strategy
      try {
        query = sequel.create(tableName, data);
      } catch(e) {
        return cb(e);
      }

      // Run Query
      client.query(query.query, query.values, function __CREATE_EACH__(err, result) {
        if(err) return cb(handleQueryError(err));

        // Cast special values
        var values = processor.cast(tableName, result.rows[0]);

        results.push(values);
        if(incrementSequences.length === 0) return cb(null, values);

        function checkSequence(item, next) {
          var currentValue  = item.value;
          var sequenceValue = values[item.key];

          if(currentValue &#x3c; sequenceValue) {
            item.value = sequenceValue;
          }
          next();
        }

        async.each(incrementSequences, checkSequence, function(err) {
          if(err) return cb(err);
          cb(null, values);
        });
      });

    }, function(err) {
      if(err) return cb(err);
      if(incrementSequences.length === 0) return cb(null, results);

      function setSequence(item, next) {
        if (sequenceValue === 0) {return next();}
        var sequenceName = &#x22;&#x27;\&#x22;&#x22; + schemaName + &#x27;\&#x22;.\&#x22;&#x27; + tableName + &#x27;_&#x27; + item.key + &#x27;_seq&#x27; + &#x22;\&#x22;&#x27;&#x22;;
        var sequenceValue = item.value;
        var sequenceQuery = &#x27;SELECT setval(&#x27; + sequenceName + &#x27;, &#x27; + sequenceValue + &#x27;, true)&#x27;;

        client.query(sequenceQuery, function(err, result) {
          if(err) return next(err);
          next();
        });
      }

      async.each(incrementSequences, setSequence, function(err) {
        if(err) return cb(err);
        cb(null, results);
      });
    });

  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sails-postgresql.createSchema" id="apidoc.module.sails-postgresql.createSchema">module sails-postgresql.createSchema</a></h1>


    <h2>
        <a href="#apidoc.element.sails-postgresql.createSchema.createSchema" id="apidoc.element.sails-postgresql.createSchema.createSchema">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>createSchema
        <span class="apidocSignatureSpan">(connectionName, table, schemaName, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createSchema = function (connectionName, table, schemaName, cb) {

  if (&#x27;function&#x27; == typeof schemaName) {
    cb = schemaName;
    schemaName = getSchema(connectionName, table);
  }
  if (!schemaName) {
    throw new Error(&#x22;No schemaName specified, and could not determined schemaname for table `&#x22; + table + &#x22;`&#x22;);
  }

  // Build Query
  var query = &#x27;CREATE SCHEMA &#x22;&#x27; + schemaName + &#x27;&#x22;&#x27;;

  spawnConnection(connectionName, function (client, cb) {
    // Run Query
    client.query(query, function (err, result) {
      // If we get a &#x22;duplicate schema&#x22; error, just silently ignore it
      if (err &#x26;&#x26; err.code == &#x27;42P06&#x27;) {return cb();}
      // If we get any other type of error, return it
      if (err) {
        err.type = &#x27;CREATING_SCHEMA&#x27;;
        err.schemaName = schemaName;
        return cb(err);
      }
      // It we get no error, we&#x27;re all good.
      return cb();
    });
  }, cb);

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sails-postgresql.define" id="apidoc.module.sails-postgresql.define">module sails-postgresql.define</a></h1>


    <h2>
        <a href="#apidoc.element.sails-postgresql.define.define" id="apidoc.element.sails-postgresql.define.define">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>define
        <span class="apidocSignatureSpan">(connectionName, table, definition, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">define = function (connectionName, table, definition, cb) {

  // Create a describe method to run after the define.
  // Ensures the define connection is properly closed.
  var describe = function(err, result) {
    if(err) return cb(err);

    // Describe (sets schema)
    adapter.describe(connectionName, table.replace(/[&#x22;&#x27;]/g, &#x22;&#x22;), cb);
  };

  var connectionObject = connections[connectionName];

  spawnConnection(connectionName, function __DEFINE__(client, cb) {

    // Get the schema name if any
    var schemaName = getSchema(connectionName, table);

    // If we&#x27;re being told NOT to create schemas, then skip right to
    // creating the table.
    if (connectionObject.config.createSchemas === false) {return _define();}

    // If the schema name is &#x22;public&#x22;, just finish creating the table
    if (schemaName == &#x27;public&#x27;) {return _define();}

    // If not, attempt to create the schema first.  This will succeed if
    // the schema already exists.
    adapter.createSchema(connectionName, table, schemaName, _define);

    function _define(errCreatingSchema) {

      if (errCreatingSchema) {
        cb(handleQueryError(errCreatingSchema));
      }

      // Escape Table Name
      var tableName = utils.escapeName(table, schemaName);

      // Iterate through each attribute, building a query string
      var _schema = utils.buildSchema(definition);

      // Check for any Index attributes
      var indexes = utils.buildIndexes(definition);

      // Build Query
      var query = &#x27;CREATE TABLE &#x27; + tableName + &#x27; (&#x27; + _schema + &#x27;)&#x27;;

      // Run Query
      client.query(query, function __DEFINE__(err, result) {

        if(err) {
          if (err.code == &#x27;3F000&#x27;) {
            err.table = table;
            err.schemaName = schemaName;
          }
          return cb(handleQueryError(err));
        }

        // Build Indexes
        function buildIndex(name, cb) {

          // Strip slashes from table name, used to namespace index
          var cleanTable = table.replace(/[&#x27;&#x22;]/g, &#x27;&#x27;);

          // Build a query to create a namespaced index tableName_key
          var query = &#x27;CREATE INDEX &#x27; + utils.escapeName(cleanTable + &#x27;_&#x27; + name) + &#x27; on &#x27; + tableName + &#x27; (&#x27; + utils.escapeName
(name) + &#x27;);&#x27;;
          // Run Query
          client.query(query, function(err, result) {
            if(err) return cb(handleQueryError(err));
            cb();
          });
        }

        // Build indexes in series
        async.eachSeries(indexes, buildIndex, cb);
      });

    }

  }, describe);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sails-postgresql.describe" id="apidoc.module.sails-postgresql.describe">module sails-postgresql.describe</a></h1>


    <h2>
        <a href="#apidoc.element.sails-postgresql.describe.describe" id="apidoc.element.sails-postgresql.describe.describe">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>describe
        <span class="apidocSignatureSpan">(connectionName, table, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">describe = function (connectionName, table, cb) {
  spawnConnection(connectionName, function __DESCRIBE__(client, cb) {

    var connectionObject = connections[connectionName];
    var collection = connectionObject.collections[table];
    var tableName = table;
    var schemaName = getSchema(connectionName, table);

    // Build query to get a bunch of info from the information_schema
    // It&#x27;s not super important to understand it only that it returns the following fields:
    // [Table, #, Column, Type, Null, Constraint, C, consrc, F Key, Default]
    var query = &#x22;SELECT x.nspname || &#x27;.&#x27; || x.relname as \&#x22;Table\&#x22;, x.attnum as \&#x22;#\&#x22;, x.attname as \&#x22;Column\&#x22;, x.\&#x22;Type\&#x22;,&#x22; +
      &#x22; case x.attnotnull when true then &#x27;NOT NULL&#x27; else &#x27;&#x27; end as \&#x22;NULL\&#x22;, r.conname as \&#x22;Constraint\&#x22;, r.contype as \&#x22;C\&#x22;, &#x22; +
      &#x22;r.consrc, fn.nspname || &#x27;.&#x27; || f.relname as \&#x22;F Key\&#x22;, d.adsrc as \&#x22;Default\&#x22; FROM (&#x22; +
      &#x22;SELECT c.oid, a.attrelid, a.attnum, n.nspname, c.relname, a.attname, pg_catalog.format_type(a.atttypid, a.atttypmod) as \&#x22;
Type\&#x22;, &#x22; +
      &#x22;a.attnotnull FROM pg_catalog.pg_attribute a, pg_namespace n, pg_class c WHERE a.attnum &#x3e; 0 AND NOT a.attisdropped AND a.attrelid
 = c.oid &#x22; +
      &#x22;and c.relkind not in (&#x27;S&#x27;,&#x27;v&#x27;) and c.relnamespace = n.oid and n.nspname not in (&#x27;pg_catalog&#x27;,&#x27;pg_toast&#x27;,&#x27;information_schema
&#x27;)) x &#x22; +
      &#x22;left join pg_attrdef d on d.adrelid = x.attrelid and d.adnum = x.attnum &#x22; +
      &#x22;left join pg_constraint r on r.conrelid = x.oid and r.conkey[1] = x.attnum &#x22; +
      &#x22;left join pg_class f on r.confrelid = f.oid &#x22; +
      &#x22;left join pg_namespace fn on f.relnamespace = fn.oid &#x22; +
      &#x22;where x.relname = &#x27;&#x22; + tableName + &#x22;&#x27; and x.nspname = &#x27;&#x22; + schemaName + &#x22;&#x27; order by 1,2;&#x22;;

    // Get Sequences to test if column auto-increments
    var autoIncrementQuery = &#x22;SELECT t.relname as related_table, a.attname as related_column, s.relname as sequence_name &#x22; +
      &#x22;FROM pg_class s JOIN pg_depend d ON d.objid = s.oid JOIN pg_class t ON d.objid = s.oid AND d.refobjid = t.oid &#x22; +
      &#x22;JOIN pg_attribute a ON (d.refobjid, d.refobjsubid) = (a.attrelid, a.attnum) JOIN pg_namespace n ON n.oid = s.relnamespace
 &#x22; +
      &#x22;WHERE s.relkind = &#x27;S&#x27; AND n.nspname = &#x27;&#x22; + schemaName + &#x22;&#x27;;&#x22;;

    // Get Indexes
    var indiciesQuery = &#x22;SELECT n.nspname as \&#x22;Schema\&#x22;, c.relname as \&#x22;Name\&#x22;, CASE c.relkind WHEN &#x27;r&#x27; THEN &#x27;table&#x27; &#x22; +
      &#x22;WHEN &#x27;v&#x27; THEN &#x27;view&#x27; WHEN &#x27;i&#x27; THEN &#x27;index&#x27; WHEN &#x27;S&#x27; THEN &#x27;sequence&#x27; WHEN &#x27;s&#x27; THEN &#x27;special&#x27; WHEN &#x27;f&#x27; THEN &#x22; +
      &#x22;&#x27;foreign table&#x27; END as \&#x22;Type\&#x22;, pg_catalog.pg_get_userbyid(c.relowner) as \&#x22;Owner\&#x22;, c2.relname as \&#x22;Table\&#x22; &#x22; +
      &#x22;FROM pg_catalog.pg_class c LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace &#x22; +
      &#x22;LEFT JOIN pg_catalog.pg_index i ON i.indexrelid = c.oid &#x22; +
      &#x22;LEFT JOIN pg_catalog.pg_class c2 ON i.indrelid = c2.oid &#x22; +
      &#x22;WHERE c.relkind IN (&#x27;i&#x27;,&#x27;&#x27;) AND n.nspname &#x3c;&#x3e; &#x27;pg_catalog&#x27; AND n.nspname &#x3c;&#x3e; &#x27;information_schema&#x27; &#x22; +
      &#x22;AND n.nspname !~ &#x27;^pg_toast&#x27; AND pg_catalog.pg_table_is_visible(c.oid) ORDER BY 1,2;&#x22;;

    // Run Info Query
    client.query(query, function(err, result) {
      if(err) return cb(handleQueryError(err));
      if(result.rows.length === 0) return cb();

      // Run Query to get Auto Incrementing sequences
      client.query(autoIncrementQuery, function(err, aResult) {
        if(err) return cb(handleQueryError(err));

        aResult.rows.forEach(function(row) {
          if(row.related_table !== table) return;

          // Look through query results and see if related_column exists
          result.rows.forEach(function(column) {
            if(column.Column !== row.related_column) return;
            column.autoIncrement = true;
          });
        });

        // Run Query to get Indexed values
        client.query(indiciesQuery, function(err, iResult) {
          if(err) return cb(handleQueryError(err));

          // Loop through indicies and see if any match
          iResult.rows.forEach(function(column) {
            var key = column.Name.split(&#x27;_index_&#x27;)[1];

            // Look through query results and see if key e ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sails-postgresql.destroy" id="apidoc.module.sails-postgresql.destroy">module sails-postgresql.destroy</a></h1>


    <h2>
        <a href="#apidoc.element.sails-postgresql.destroy.destroy" id="apidoc.element.sails-postgresql.destroy.destroy">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>destroy
        <span class="apidocSignatureSpan">(connectionName, table, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destroy = function (connectionName, table, options, cb) {
  spawnConnection(connectionName, function __DELETE__(client, cb) {

    var connectionObject = connections[connectionName];
    var collection = connectionObject.collections[table];
    var tableName = table;

    var _schema = connectionObject.schema;

    // Mixin WL Next connection overrides to sqlOptions
    var overrides = connectionOverrides[connectionName] || {};
    var _options = _.cloneDeep(sqlOptions);
    if(hop(overrides, &#x27;wlNext&#x27;)) {
      _options.wlNext = overrides.wlNext;
    }

    var sequel = new Sequel(_schema, _options);
    var query;

    // Build a query for the specific query strategy
    try {
      query = sequel.destroy(tableName, options);
    } catch(e) {
      return cb(e);
    }

    // Run Query
    client.query(query.query, query.values, function __DELETE__(err, result) {
      if(err) return cb(handleQueryError(err));
      cb(null, result.rows);
    });

  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sails-postgresql.drop" id="apidoc.module.sails-postgresql.drop">module sails-postgresql.drop</a></h1>


    <h2>
        <a href="#apidoc.element.sails-postgresql.drop.drop" id="apidoc.element.sails-postgresql.drop.drop">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>drop
        <span class="apidocSignatureSpan">(connectionName, table, relations, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">drop = function (connectionName, table, relations, cb) {

  if(typeof relations === &#x27;function&#x27;) {
    cb = relations;
    relations = [];
  }

  spawnConnection(connectionName, function __DROP__(client, cb) {

    // Drop any relations
    function dropTable(item, next) {

      var tableName = utils.escapeName(item, getSchema(connectionName, item));

      // Build Query
      var query = &#x27;DROP TABLE &#x27; + tableName + &#x27;;&#x27;;

      // Run Query
      client.query(query, function __DROP__(err, result) {
        if(err) result = null;
        next(null, result);
      });
    }

    async.eachSeries(relations, dropTable, function(err) {
      if(err) return cb(err);
      dropTable(table, cb);
    });

  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sails-postgresql.find" id="apidoc.module.sails-postgresql.find">module sails-postgresql.find</a></h1>


    <h2>
        <a href="#apidoc.element.sails-postgresql.find.find" id="apidoc.element.sails-postgresql.find.find">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>find
        <span class="apidocSignatureSpan">(connectionName, table, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">find = function (connectionName, table, options, cb) {
  spawnConnection(connectionName, function __FIND__(client, cb) {

    // Grab Connection Schema
    var schema = {};
    var connectionObject = connections[connectionName];
    var collection = connectionObject.collections[table];
    var tableName = table;

    Object.keys(connectionObject.collections).forEach(function(coll) {
      schema[coll] = connectionObject.collections[coll].schema;
    });

    // Build Query
    var _schema = connectionObject.schema;
    var processor = new Processor(_schema);

    // Mixin WL Next connection overrides to sqlOptions
    var overrides = connectionOverrides[connectionName] || {};
    var _options = _.cloneDeep(sqlOptions);
    if(hop(overrides, &#x27;wlNext&#x27;)) {
      _options.wlNext = overrides.wlNext;
    }

    var sequel = new Sequel(_schema, _options);
    var _query;

    // Build a query for the specific query strategy
    try {
      _query = sequel.find(tableName, options);
    } catch(e) {
      return cb(e);
    }
    client.query(_query.query[0], _query.values[0], function __FIND__(err, result) {
      if(err) return cb(handleQueryError(err));

      // Cast special values
      var values = [];

      result.rows.forEach(function(row) {
        values.push(processor.cast(tableName, row));
      });

      return cb(null, values);
    });

  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sails-postgresql.join" id="apidoc.module.sails-postgresql.join">module sails-postgresql.join</a></h1>


    <h2>
        <a href="#apidoc.element.sails-postgresql.join.join" id="apidoc.element.sails-postgresql.join.join">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>join
        <span class="apidocSignatureSpan">(connectionName, table, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">join = function (connectionName, table, options, cb) {

  spawnConnection(connectionName, function __FIND__(client, done) {

    // Populate associated records for each parent result
    // (or do them all at once as an optimization, if possible)
    Cursor({

      instructions: options,
      nativeJoins: true,

<span class="apidocCodeCommentSpan">      /**
       * Find some records directly (using only this adapter)
       * from the specified collection.
       *
       * @param  {String}   collectionIdentity
       * @param  {Object}   criteria
       * @param  {Function} _cb
       */
</span>      $find: function (collectionName, criteria, _cb) {
        return adapter.find(conn, collectionIdentity, criteria, _cb, client);
      },

      /**
       * Look up the name of the primary key field
       * for the collection with the specified identity.
       *
       * @param  {String}   collectionIdentity
       * @return {String}
       */
      $getPK: function (collectionName) {
        if (!collectionName) return;
        return _getPK(connectionName, collectionName);
      },

      /**
       * Given a strategy type, build up and execute a SQL query for it.
       *
       * @param {}
       */

      $populateBuffers: function populateBuffers(options, next) {

        var buffers = options.buffers;
        var instructions = options.instructions;

        // Grab the collection by looking into the connection
        var connectionObject = connections[connectionName];
        var collection = connectionObject.collections[table];
        var tableName = table;

        var parentRecords = [];
        var cachedChildren = {};

        // Grab Connection Schema
        var schema = {};

        Object.keys(connectionObject.collections).forEach(function(coll) {
          schema[coll] = connectionObject.collections[coll].schema;
        });

        // Build Query
        var _schema = connectionObject.schema;

        // Mixin WL Next connection overrides to sqlOptions
        var overrides = connectionOverrides[connectionName] || {};
        var _options = _.cloneDeep(sqlOptions);
        if(hop(overrides, &#x27;wlNext&#x27;)) {
          _options.wlNext = overrides.wlNext;
        }

        var sequel = new Sequel(_schema, _options);
        var _query;

        // Build a query for the specific query strategy
        try {
          _query = sequel.find(tableName, instructions);
        } catch(e) {
          return next(e);
        }

        async.auto({

          processParent: function(next) {

            client.query(_query.query[0], _query.values[0], function __FIND__(err, result) {
              if(err) return next(handleQueryError(err));

              parentRecords = result.rows;

              var splitChildren = function(parent, next) {
                var cache = {};

                _.keys(parent).forEach(function(key) {

                  // Check if we can split this on our special alias identifier &#x27;___&#x27; and if
                  // so put the result in the cache
                  var split = key.split(&#x27;___&#x27;);
                  if(split.length &#x3c; 2) return;

                  if(!hop(cache, split[0])) cache[split[0]] = {};
                  cache[split[0]][split[1]] = parent[key];
                  delete parent[key];
                });

                // Combine the local cache into the cachedChildren
                if(_.keys(cache).length &#x3e; 0) {
                  _.keys(cache).forEach(function(pop) {
                    if(!hop(cachedChildren, pop)) cachedChildren[pop] = [];
                    cachedChildren[pop] = cachedChildren[pop].concat(cache[pop]);
                  });
                }

                next();
              };


              // Pull out any aliased child records that have come from a hasFK association
              async.eachSeries(parentRecords, splitChildren, function(err) {
                if(err) return next(err);
                buffers.parents = parentRecords;
                next();
              });
            });
          },

          // Build child buffers.
          // For each instruction, loop through the p ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    attribute.type = val;
  }

  var type = utils.sqlTypeCast(attribute.autoIncrement ? &#x27;SERIAL&#x27; : attribute.type);
  var nullable = attribute.notNull &#x26;&#x26; &#x27;NOT NULL&#x27;;
  var unique = attribute.unique &#x26;&#x26; &#x27;UNIQUE&#x27;;

  return _.compact([ &#x27;&#x22;&#x27; + name + &#x27;&#x22;&#x27;, type, nullable, unique ]).<span class="apidocCodeKeywordSpan
">join</span>(&#x27; &#x27;);
}).join(&#x27;,&#x27;);

var primaryKeys = _.keys(_.pick(obj, function (attribute) {
  return attribute.primaryKey;
}));

var constraints = _.compact([
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sails-postgresql.processor" id="apidoc.module.sails-postgresql.processor">module sails-postgresql.processor</a></h1>


    <h2>
        <a href="#apidoc.element.sails-postgresql.processor.processor" id="apidoc.element.sails-postgresql.processor.processor">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>processor
        <span class="apidocSignatureSpan">(schema)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Processor(schema) {
  this.schema = _.cloneDeep(schema);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sails-postgresql.processor.prototype" id="apidoc.module.sails-postgresql.processor.prototype">module sails-postgresql.processor.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.sails-postgresql.processor.prototype.cast" id="apidoc.element.sails-postgresql.processor.prototype.cast">
        function <span class="apidocSignatureSpan">sails-postgresql.processor.prototype.</span>cast
        <span class="apidocSignatureSpan">(table, values)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cast = function (table, values) {

  var self = this;
  var _values = _.cloneDeep(values);

  Object.keys(values).forEach(function(key) {
    self.castValue(table, key, _values[key], _values);
  });

  return _values;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sails-postgresql.processor.prototype.castValue" id="apidoc.element.sails-postgresql.processor.prototype.castValue">
        function <span class="apidocSignatureSpan">sails-postgresql.processor.prototype.</span>castValue
        <span class="apidocSignatureSpan">(table, key, value, attributes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">castValue = function (table, key, value, attributes) {

  var self = this;
  var identity = table;
  var attr;

  // Check for a columnName, serialize so we can do any casting
  Object.keys(this.schema[identity].attributes).forEach(function(attribute) {
    if(self.schema[identity].attributes[attribute].columnName === key) {
      attr = attribute;
      return;
    }
  });

  if(!attr) attr = key;

  // Lookup Schema &#x22;Type&#x22;
  if(!this.schema[identity] || !this.schema[identity].attributes[attr]) return;
  var type;

  if(!_.isPlainObject(this.schema[identity].attributes[attr])) {
    type = this.schema[identity].attributes[attr];
  } else {
    type = this.schema[identity].attributes[attr].type;
  }


  if(!type) return;

  // Attempt to parse Array
  if(type === &#x27;array&#x27;) {
    try {
      attributes[key] = JSON.parse(value);
    } catch(e) {
      return;
    }
  }

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Processor.prototype.cast = function(table, values) {

 var self = this;
 var _values = _.cloneDeep(values);

 Object.keys(values).forEach(function(key) {
   self.<span class="apidocCodeKeywordSpan">castValue</span>(table, key, _values[key], _values);
 });

 return _values;
};

/**
* Cast a value
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sails-postgresql.query" id="apidoc.module.sails-postgresql.query">module sails-postgresql.query</a></h1>


    <h2>
        <a href="#apidoc.element.sails-postgresql.query.query" id="apidoc.element.sails-postgresql.query.query">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>query
        <span class="apidocSignatureSpan">(connectionName, table, query, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">query = function (connectionName, table, query, data, cb) {

  if (_.isFunction(data)) {
    cb = data;
    data = null;
  }

  spawnConnection(connectionName, function __QUERY__(client, cb) {

    // Run query
    if (data) client.query(query, data, cb);
    else client.query(query, cb);

  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sails-postgresql.registerConnection" id="apidoc.module.sails-postgresql.registerConnection">module sails-postgresql.registerConnection</a></h1>


    <h2>
        <a href="#apidoc.element.sails-postgresql.registerConnection.registerConnection" id="apidoc.element.sails-postgresql.registerConnection.registerConnection">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>registerConnection
        <span class="apidocSignatureSpan">(connection, collections, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerConnection = function (connection, collections, cb) {

  var self = this;

  if(!connection.identity) return cb(Errors.IdentityMissing);
  if(connections[connection.identity]) return cb(Errors.IdentityDuplicate);

  // Store any connection overrides
  connectionOverrides[connection.identity] = {};

  // Look for the WL Next key
  if(hop(connection, &#x27;wlNext&#x27;)) {
    connectionOverrides[connection.identity].wlNext = _.cloneDeep(connection.wlNext);
  }

  // Build up a schema for this connection that can be used throughout the adapter
  var schema = {};

  _.each(_.keys(collections), function(coll) {
    var collection = collections[coll];
    if(!collection) return;

    var _schema = collection.waterline &#x26;&#x26; collection.waterline.schema &#x26;&#x26; collection.waterline.schema[collection.identity];
    if(!_schema) return;

    // Set defaults to ensure values are set
    if(!_schema.attributes) _schema.attributes = {};
    if(!_schema.tableName) _schema.tableName = coll;

    // If the connection names are&#x27;t the same we don&#x27;t need it in the schema
    if(!_.includes(collections[coll].connection, connection.identity)) {
      return;
    }

    // If this collection has a schema name set, make sure that it&#x27;s passed
    // through to the options for waterline-sequel.
    if(hop(collection, &#x27;meta&#x27;) &#x26;&#x26; hop(collection.meta, &#x27;schemaName&#x27;)) {
      sqlOptions.schemaName[_schema.tableName] = collection.meta.schemaName;
    } else {
      sqlOptions.schemaName[_schema.tableName] = &#x22;public&#x22;;
    }

    // If the tableName is different from the identity, store the tableName in the schema
    var schemaKey = coll;
    if(_schema.tableName != coll) {
      schemaKey = _schema.tableName;
    }

    schema[schemaKey] = _schema;
  });

  // Store the connection
  connections[connection.identity] = {
    config: connection,
    collections: collections,
    schema: schema
  };

  // Always call describe
  async.map(Object.keys(collections), function(colName, cb){
    self.describe(connection.identity, colName, cb);
  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sails-postgresql.removeAttribute" id="apidoc.module.sails-postgresql.removeAttribute">module sails-postgresql.removeAttribute</a></h1>


    <h2>
        <a href="#apidoc.element.sails-postgresql.removeAttribute.removeAttribute" id="apidoc.element.sails-postgresql.removeAttribute.removeAttribute">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>removeAttribute
        <span class="apidocSignatureSpan">(connectionName, table, attrName, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeAttribute = function (connectionName, table, attrName, cb) {
  spawnConnection(connectionName, function __REMOVE_ATTRIBUTE__(client, cb) {

    // Escape Table Name
    table = utils.escapeName(table, getSchema(connectionName, table));

    // Build Query
    var query = &#x27;ALTER TABLE &#x27; + table + &#x27; DROP COLUMN &#x22;&#x27; + attrName + &#x27;&#x22; RESTRICT&#x27;;

    // Run Query
    client.query(query, function __REMOVE_ATTRIBUTE__(err, result) {
      if(err) return cb(handleQueryError(err));
      cb(null, result.rows);
    });

  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sails-postgresql.stream" id="apidoc.module.sails-postgresql.stream">module sails-postgresql.stream</a></h1>


    <h2>
        <a href="#apidoc.element.sails-postgresql.stream.stream" id="apidoc.element.sails-postgresql.stream.stream">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>stream
        <span class="apidocSignatureSpan">(connectionName, table, options, stream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stream = function (connectionName, table, options, stream) {

  var connectionObject = connections[connectionName];
  var collection = connectionObject.collections[table];

  var client = new pg.Client(connectionObject.config);
  client.connect();

  var schema = {};

  Object.keys(connectionObject.collections).forEach(function(coll) {
    schema[coll] = connectionObject.collections[coll].schema;
  });

  // Build Query
  var _schema = collection.schema;
  var queryObj = new Query(_schema, schema);
  var query =queryObj.find(table, options);

  // Run Query
  var dbStream = client.query(query.query, query.values);

  //can stream row results back 1 at a time
  dbStream.on(&#x27;row&#x27;, function(row) {
    stream.write(row);
  });

  dbStream.on(&#x27;error&#x27;, function(err) {
    stream.end(); // End stream
    client.end(); // Close Connection
  });

  //fired after last row is emitted
  dbStream.on(&#x27;end&#x27;, function() {
    stream.end(); // End stream
    client.end(); // Close Connection
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sails-postgresql.teardown" id="apidoc.module.sails-postgresql.teardown">module sails-postgresql.teardown</a></h1>


    <h2>
        <a href="#apidoc.element.sails-postgresql.teardown.teardown" id="apidoc.element.sails-postgresql.teardown.teardown">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>teardown
        <span class="apidocSignatureSpan">(conn, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">teardown = function (conn, cb) {
  if (typeof conn == &#x27;function&#x27;) {
    cb = conn;
    conn = null;
  }
  if (conn === null) {
    connections = {};
    return cb();
  }
  if(!connections[conn]) return cb();
  delete connections[conn];
  cb();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sails-postgresql.update" id="apidoc.module.sails-postgresql.update">module sails-postgresql.update</a></h1>


    <h2>
        <a href="#apidoc.element.sails-postgresql.update.update" id="apidoc.element.sails-postgresql.update.update">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>update
        <span class="apidocSignatureSpan">(connectionName, table, options, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">update = function (connectionName, table, options, data, cb) {
  //LIMIT in a postgresql UPDATE command is not valid
  if (hop(options, &#x27;limit&#x27;)) {
    return cb(new Error(&#x27;Your \&#x27;LIMIT &#x27; + options.limit + &#x27;\&#x27; is not allowed in the PostgreSQL UPDATE query.&#x27;));
  }
  spawnConnection(connectionName, function __UPDATE__(client, cb) {

    var connectionObject = connections[connectionName];
    var collection = connectionObject.collections[table];
    var tableName = table;

    var _schema = connectionObject.schema;
    var processor = new Processor(_schema);

    // Mixin WL Next connection overrides to sqlOptions
    var overrides = connectionOverrides[connectionName] || {};
    var _options = _.cloneDeep(sqlOptions);
    if(hop(overrides, &#x27;wlNext&#x27;)) {
      _options.wlNext = overrides.wlNext;
    }

    var sequel = new Sequel(_schema, _options);
    var query;

    // Build a query for the specific query strategy
    try {
      query = sequel.update(tableName, options, data);
    } catch(e) {
      return cb(e);
    }

    // Run Query
    client.query(query.query, query.values, function __UPDATE__(err, result) {
      if(err) return cb(handleQueryError(err));

      // Cast special values
      var values = [];

      result.rows.forEach(function(row) {
        values.push(processor.cast(tableName, row));
      });

      cb(null, values);
    });

  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sails-postgresql.utils" id="apidoc.module.sails-postgresql.utils">module sails-postgresql.utils</a></h1>


    <h2>
        <a href="#apidoc.element.sails-postgresql.utils.buildIndexes" id="apidoc.element.sails-postgresql.utils.buildIndexes">
        function <span class="apidocSignatureSpan">sails-postgresql.utils.</span>buildIndexes
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildIndexes = function (obj) {
  var indexes = [];

  // Iterate through the Object keys and pull out any index attributes
  Object.keys(obj).forEach(function(key) {
    if(obj[key].hasOwnProperty(&#x27;index&#x27;)) {
      indexes.push(key);
    }
  });

  return indexes;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sails-postgresql.utils.buildSchema" id="apidoc.element.sails-postgresql.utils.buildSchema">
        function <span class="apidocSignatureSpan">sails-postgresql.utils.</span>buildSchema
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildSchema = function (obj) {
  var columns = _.map(obj, function (attribute, name) {
    if (_.isString(attribute)) {
      var val = attribute;
      attribute = {};
      attribute.type = val;
    }

    var type = utils.sqlTypeCast(attribute.autoIncrement ? &#x27;SERIAL&#x27; : attribute.type);
    var nullable = attribute.notNull &#x26;&#x26; &#x27;NOT NULL&#x27;;
    var unique = attribute.unique &#x26;&#x26; &#x27;UNIQUE&#x27;;

    return _.compact([ &#x27;&#x22;&#x27; + name + &#x27;&#x22;&#x27;, type, nullable, unique ]).join(&#x27; &#x27;);
  }).join(&#x27;,&#x27;);

  var primaryKeys = _.keys(_.pick(obj, function (attribute) {
    return attribute.primaryKey;
  }));

  var constraints = _.compact([
    primaryKeys.length &#x26;&#x26; &#x27;PRIMARY KEY (&#x22;&#x27; + primaryKeys.join(&#x27;&#x22;,&#x22;&#x27;) + &#x27;&#x22;)&#x27;
  ]).join(&#x27;, &#x27;);

  return _.compact([ columns, constraints ]).join(&#x27;, &#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sails-postgresql.utils.escapeName" id="apidoc.element.sails-postgresql.utils.escapeName">
        function <span class="apidocSignatureSpan">sails-postgresql.utils.</span>escapeName
        <span class="apidocSignatureSpan">(name, schema)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function escapeName(name, schema) {
  name = &#x27;&#x22;&#x27; + name + &#x27;&#x22;&#x27;;
  if (schema) {
    name = &#x27;&#x22;&#x27; + schema + &#x27;&#x22;.&#x27; + name;
  }
  return name;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sails-postgresql.utils.mapAttributes" id="apidoc.element.sails-postgresql.utils.mapAttributes">
        function <span class="apidocSignatureSpan">sails-postgresql.utils.</span>mapAttributes
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mapAttributes = function (data) {
  var keys = [],   // Column Names
      values = [], // Column Values
      params = [], // Param Index, ex: $1, $2
      i = 1;

  Object.keys(data).forEach(function(key) {
    keys.push(&#x27;&#x22;&#x27; + key + &#x27;&#x22;&#x27;);
    values.push(utils.prepareValue(data[key]));
    params.push(&#x27;$&#x27; + i);
    i++;
  });

  return({ keys: keys, values: values, params: params });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sails-postgresql.utils.marshalConfig" id="apidoc.element.sails-postgresql.utils.marshalConfig">
        function <span class="apidocSignatureSpan">sails-postgresql.utils.</span>marshalConfig
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">marshalConfig = function (config) {
  return _.extend(config, {
    host: config.host,
    user: config.user,
    password: config.password,
    database: config.database,
    port: config.port
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sails-postgresql.utils.normalizeSchema" id="apidoc.element.sails-postgresql.utils.normalizeSchema">
        function <span class="apidocSignatureSpan">sails-postgresql.utils.</span>normalizeSchema
        <span class="apidocSignatureSpan">(schema)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">normalizeSchema = function (schema) {
  var normalized = {};
  var clone = _.clone(schema);

  clone.forEach(function(column) {

    // Set Type
    normalized[column.Column] = {
      type: column.Type
    };

    // Check for Primary Key
    if(column.Constraint &#x26;&#x26; column.C === &#x27;p&#x27;) {
      normalized[column.Column].primaryKey = true;
    }

    // Check for Unique Constraint
    if(column.Constraint &#x26;&#x26; column.C === &#x27;u&#x27;) {
      normalized[column.Column].unique = true;
    }

    // Check for autoIncrement
    if(column.autoIncrement) {
      normalized[column.Column].autoIncrement = column.autoIncrement;
    }

    // Check for index
    if(column.indexed) {
      normalized[column.Column].indexed = column.indexed;
    }

  });

  return normalized;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sails-postgresql.utils.prepareValue" id="apidoc.element.sails-postgresql.utils.prepareValue">
        function <span class="apidocSignatureSpan">sails-postgresql.utils.</span>prepareValue
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prepareValue = function (value) {

  // Cast dates to SQL
  if (_.isDate(value)) {
    value = utils.toSqlDate(value);
  }

  // Cast functions to strings
  if (_.isFunction(value)) {
    value = value.toString();
  }

  // Store Arrays as strings
  if (Array.isArray(value)) {
    value = JSON.stringify(value);
  }

  // Store Buffers as hex strings (for BYTEA)
  if (Buffer.isBuffer(value)) {
    value = &#x27;\\x&#x27; + value.toString(&#x27;hex&#x27;);
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var keys = [],   // Column Names
      values = [], // Column Values
      params = [], // Param Index, ex: $1, $2
      i = 1;

  Object.keys(data).forEach(function(key) {
    keys.push(&#x27;&#x22;&#x27; + key + &#x27;&#x22;&#x27;);
    values.push(utils.<span class="apidocCodeKeywordSpan">prepareValue</span>(data[key]));
    params.push(&#x27;$&#x27; + i);
    i++;
  });

  return({ keys: keys, values: values, params: params });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sails-postgresql.utils.sqlTypeCast" id="apidoc.element.sails-postgresql.utils.sqlTypeCast">
        function <span class="apidocSignatureSpan">sails-postgresql.utils.</span>sqlTypeCast
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sqlTypeCast = function (type) {
  switch (type.toLowerCase()) {
    case &#x27;serial&#x27;:
      return &#x27;SERIAL&#x27;;
    case &#x27;smallserial&#x27;:
      return &#x27;SMALLSERIAL&#x27;;
    case &#x27;bigserial&#x27;:
      return &#x27;BIGSERIAL&#x27;;

    case &#x27;string&#x27;:
    case &#x27;text&#x27;:
    case &#x27;mediumtext&#x27;:
    case &#x27;longtext&#x27;:
      return &#x27;TEXT&#x27;;

    case &#x27;boolean&#x27;:
      return &#x27;BOOLEAN&#x27;;

    case &#x27;int&#x27;:
    case &#x27;integer&#x27;:
      return &#x27;INT&#x27;;

    case &#x27;smallint&#x27;:
      return &#x27;SMALLINT&#x27;;
    case &#x27;bigint&#x27;:
      return &#x27;BIGINT&#x27;;
    case &#x27;real&#x27;:
    case &#x27;float&#x27;:
      return &#x27;REAL&#x27;;
    case &#x27;double&#x27;:
      return &#x27;DOUBLE PRECISION&#x27;;
    case &#x27;decimal&#x27;:
      return &#x27;DECIMAL&#x27;;

    // Store all time with the time zone
    case &#x27;time&#x27;:
        return &#x27;TIME WITH TIME ZONE&#x27;;
    // Store all dates as timestamps with the time zone
    case &#x27;date&#x27;:
      return &#x27;DATE&#x27;;
    case &#x27;datestamp&#x27;:
    case &#x27;datetime&#x27;:
      return &#x27;TIMESTAMP WITH TIME ZONE&#x27;;

    case &#x27;array&#x27;:
      return &#x27;TEXT&#x27;;

    case &#x27;json&#x27;:
      return &#x27;JSON&#x27;;

    case &#x27;binary&#x27;:
    case &#x27;bytea&#x27;:
      return &#x27;BYTEA&#x27;;

    default:
      console.error(&#x22;Unregistered type given: &#x22; + type);
      return &#x22;TEXT&#x22;;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var columns = _.map(obj, function (attribute, name) {
  if (_.isString(attribute)) {
    var val = attribute;
    attribute = {};
    attribute.type = val;
  }

  var type = utils.<span class="apidocCodeKeywordSpan">sqlTypeCast</span>(attribute.autoIncrement ? &#x27;SERIAL&#x27; : attribute
.type);
  var nullable = attribute.notNull &#x26;&#x26; &#x27;NOT NULL&#x27;;
  var unique = attribute.unique &#x26;&#x26; &#x27;UNIQUE&#x27;;

  return _.compact([ &#x27;&#x22;&#x27; + name + &#x27;&#x22;&#x27;, type, nullable, unique ]).join(&#x27; &#x27;);
}).join(&#x27;,&#x27;);

var primaryKeys = _.keys(_.pick(obj, function (attribute) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sails-postgresql.utils.toSqlDate" id="apidoc.element.sails-postgresql.utils.toSqlDate">
        function <span class="apidocSignatureSpan">sails-postgresql.utils.</span>toSqlDate
        <span class="apidocSignatureSpan">(date)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toSqlDate = function (date) {
  return date.toUTCString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * to strings.
 */

utils.prepareValue = function(value) {

// Cast dates to SQL
if (_.isDate(value)) {
  value = utils.<span class="apidocCodeKeywordSpan">toSqlDate</span>(value);
}

// Cast functions to strings
if (_.isFunction(value)) {
  value = value.toString();
}
...</pre></li>
    </ul>




</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
