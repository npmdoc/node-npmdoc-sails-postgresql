<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/balderdashy/sails-postgresql#readme">sails-postgresql (v0.11.4)</a>
</h1>
<h4>a postgreSQL adapter for Waterline and Sails.js</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.sails-postgresql">module sails-postgresql</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">sails-postgresql.</span>syncable</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.addAttribute">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>addAttribute
            <span class="apidocSignatureSpan">(connectionName, table, attrName, attrDef, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.count">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>count
            <span class="apidocSignatureSpan">(connectionName, table, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.create">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>create
            <span class="apidocSignatureSpan">(connectionName, table, data, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.createEach">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>createEach
            <span class="apidocSignatureSpan">(connectionName, table, records, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.createSchema">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>createSchema
            <span class="apidocSignatureSpan">(connectionName, table, schemaName, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.define">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>define
            <span class="apidocSignatureSpan">(connectionName, table, definition, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.describe">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>describe
            <span class="apidocSignatureSpan">(connectionName, table, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.destroy">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>destroy
            <span class="apidocSignatureSpan">(connectionName, table, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.drop">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>drop
            <span class="apidocSignatureSpan">(connectionName, table, relations, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.find">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>find
            <span class="apidocSignatureSpan">(connectionName, table, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.join">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>join
            <span class="apidocSignatureSpan">(connectionName, table, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.processor">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>processor
            <span class="apidocSignatureSpan">(schema)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.query">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>query
            <span class="apidocSignatureSpan">(connectionName, table, query, data, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.registerConnection">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>registerConnection
            <span class="apidocSignatureSpan">(connection, collections, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.removeAttribute">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>removeAttribute
            <span class="apidocSignatureSpan">(connectionName, table, attrName, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.stream">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>stream
            <span class="apidocSignatureSpan">(connectionName, table, options, stream)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.teardown">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>teardown
            <span class="apidocSignatureSpan">(conn, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.update">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>update
            <span class="apidocSignatureSpan">(connectionName, table, options, data, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sails-postgresql.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sails-postgresql.</span>processor.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sails-postgresql.</span>utils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sails-postgresql.</span>identity</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">sails-postgresql.</span>pkFormat</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sails-postgresql.addAttribute">module sails-postgresql.addAttribute</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.addAttribute.addAttribute">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>addAttribute
            <span class="apidocSignatureSpan">(connectionName, table, attrName, attrDef, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sails-postgresql.count">module sails-postgresql.count</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.count.count">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>count
            <span class="apidocSignatureSpan">(connectionName, table, options, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sails-postgresql.create">module sails-postgresql.create</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.create.create">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>create
            <span class="apidocSignatureSpan">(connectionName, table, data, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sails-postgresql.createEach">module sails-postgresql.createEach</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.createEach.createEach">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>createEach
            <span class="apidocSignatureSpan">(connectionName, table, records, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sails-postgresql.createSchema">module sails-postgresql.createSchema</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.createSchema.createSchema">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>createSchema
            <span class="apidocSignatureSpan">(connectionName, table, schemaName, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sails-postgresql.define">module sails-postgresql.define</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.define.define">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>define
            <span class="apidocSignatureSpan">(connectionName, table, definition, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sails-postgresql.describe">module sails-postgresql.describe</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.describe.describe">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>describe
            <span class="apidocSignatureSpan">(connectionName, table, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sails-postgresql.destroy">module sails-postgresql.destroy</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.destroy.destroy">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>destroy
            <span class="apidocSignatureSpan">(connectionName, table, options, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sails-postgresql.drop">module sails-postgresql.drop</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.drop.drop">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>drop
            <span class="apidocSignatureSpan">(connectionName, table, relations, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sails-postgresql.find">module sails-postgresql.find</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.find.find">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>find
            <span class="apidocSignatureSpan">(connectionName, table, options, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sails-postgresql.join">module sails-postgresql.join</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.join.join">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>join
            <span class="apidocSignatureSpan">(connectionName, table, options, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sails-postgresql.processor">module sails-postgresql.processor</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.processor.processor">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>processor
            <span class="apidocSignatureSpan">(schema)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sails-postgresql.processor.prototype">module sails-postgresql.processor.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.processor.prototype.cast">
            function <span class="apidocSignatureSpan">sails-postgresql.processor.prototype.</span>cast
            <span class="apidocSignatureSpan">(table, values)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.processor.prototype.castValue">
            function <span class="apidocSignatureSpan">sails-postgresql.processor.prototype.</span>castValue
            <span class="apidocSignatureSpan">(table, key, value, attributes)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sails-postgresql.query">module sails-postgresql.query</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.query.query">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>query
            <span class="apidocSignatureSpan">(connectionName, table, query, data, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sails-postgresql.registerConnection">module sails-postgresql.registerConnection</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.registerConnection.registerConnection">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>registerConnection
            <span class="apidocSignatureSpan">(connection, collections, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sails-postgresql.removeAttribute">module sails-postgresql.removeAttribute</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.removeAttribute.removeAttribute">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>removeAttribute
            <span class="apidocSignatureSpan">(connectionName, table, attrName, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sails-postgresql.stream">module sails-postgresql.stream</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.stream.stream">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>stream
            <span class="apidocSignatureSpan">(connectionName, table, options, stream)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sails-postgresql.teardown">module sails-postgresql.teardown</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.teardown.teardown">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>teardown
            <span class="apidocSignatureSpan">(conn, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sails-postgresql.update">module sails-postgresql.update</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.update.update">
            function <span class="apidocSignatureSpan">sails-postgresql.</span>update
            <span class="apidocSignatureSpan">(connectionName, table, options, data, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sails-postgresql.utils">module sails-postgresql.utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.utils.buildIndexes">
            function <span class="apidocSignatureSpan">sails-postgresql.utils.</span>buildIndexes
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.utils.buildSchema">
            function <span class="apidocSignatureSpan">sails-postgresql.utils.</span>buildSchema
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.utils.escapeName">
            function <span class="apidocSignatureSpan">sails-postgresql.utils.</span>escapeName
            <span class="apidocSignatureSpan">(name, schema)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.utils.mapAttributes">
            function <span class="apidocSignatureSpan">sails-postgresql.utils.</span>mapAttributes
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.utils.marshalConfig">
            function <span class="apidocSignatureSpan">sails-postgresql.utils.</span>marshalConfig
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.utils.normalizeSchema">
            function <span class="apidocSignatureSpan">sails-postgresql.utils.</span>normalizeSchema
            <span class="apidocSignatureSpan">(schema)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.utils.prepareValue">
            function <span class="apidocSignatureSpan">sails-postgresql.utils.</span>prepareValue
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.utils.sqlTypeCast">
            function <span class="apidocSignatureSpan">sails-postgresql.utils.</span>sqlTypeCast
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sails-postgresql.utils.toSqlDate">
            function <span class="apidocSignatureSpan">sails-postgresql.utils.</span>toSqlDate
            <span class="apidocSignatureSpan">(date)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sails-postgresql.utils.</span>object</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sails-postgresql" id="apidoc.module.sails-postgresql">module sails-postgresql</a></h1>




    <h2>
        <a href="#apidoc.element.sails-postgresql.addAttribute" id="apidoc.element.sails-postgresql.addAttribute">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>addAttribute
        <span class="apidocSignatureSpan">(connectionName, table, attrName, attrDef, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addAttribute = function (connectionName, table, attrName, attrDef, cb) {
  spawnConnection(connectionName, function __ADD_ATTRIBUTE__(client, cb) {

    // Escape Table Name
    table = utils.escapeName(table, getSchema(connectionName, table));

    // Setup a Schema Definition
    var attrs = {};
    attrs[attrName] = attrDef;

    var _schema = utils.buildSchema(attrs);

    // Build Query
    var query = 'ALTER TABLE ' + table + ' ADD COLUMN ' + _schema;

    // Run Query
    client.query(query, function __ADD_ATTRIBUTE__(err, result) {
      if(err) return cb(handleQueryError(err));
      cb(null, result.rows);
    });

  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sails-postgresql.count" id="apidoc.element.sails-postgresql.count">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>count
        <span class="apidocSignatureSpan">(connectionName, table, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">count = function (connectionName, table, options, cb) {
  spawnConnection(connectionName, function __COUNT__(client, cb) {

    // Grab Connection Schema
    var schema = {};
    var connectionObject = connections[connectionName];
    var collection = connectionObject.collections[table];
    var tableName = table;

    Object.keys(connectionObject.collections).forEach(function(coll) {
      schema[coll] = connectionObject.collections[coll].schema;
    });

    // Build Query
    var _schema = connectionObject.schema;
    var processor = new Processor(_schema);

    // Mixin WL Next connection overrides to sqlOptions
    var overrides = connectionOverrides[connectionName] || {};
    var _options = _.cloneDeep(sqlOptions);
    if(hop(overrides, 'wlNext')) {
      _options.wlNext = overrides.wlNext;
    }

    var sequel = new Sequel(_schema, _options);
    var _query;

    // Build a query for the specific query strategy
    try {
      _query = sequel.count(tableName, options);
    } catch(e) {
      return cb(e);
    }

    client.query(_query.query[0], _query.values[0], function __COUNT__(err, result) {
      if(err) return cb(handleQueryError(err));
      if(!_.isArray(result.rows) || !result.rows.length) {
        return cb(new Error('Invalid query, no results returned.'));
      }

      var count = result.rows[0] &amp;&amp; result.rows[0].count;
      return cb(null, Number(count));
    });

  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sails-postgresql.create" id="apidoc.element.sails-postgresql.create">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>create
        <span class="apidocSignatureSpan">(connectionName, table, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (connectionName, table, data, cb) {
  spawnConnection(connectionName, function __CREATE__(client, cb) {

    var connectionObject = connections[connectionName];
    var collection = getCollection(connectionName, table);
    var tableName = table;
    var schemaName = getSchema(collection);

    // Build up a SQL Query
    var schema = connectionObject.schema;
    var processor = new Processor(schema);

    // Mixin WL Next connection overrides to sqlOptions
    var overrides = connectionOverrides[connectionName] || {};
    var options = _.cloneDeep(sqlOptions);
    if(hop(overrides, 'wlNext')) {
      options.wlNext = overrides.wlNext;
    }

    var sequel = new Sequel(schema, options);

    var incrementSequences = [];
    var query;

    // Build a query for the specific query strategy
    try {
      query = sequel.create(table, data);
    } catch(e) {
      return cb(e);
    }

    // Loop through all the attributes being inserted and check if a sequence was used
    Object.keys(collection.schema).forEach(function(schemaKey) {
      if(!utils.object.hasOwnProperty(collection.schema[schemaKey], 'autoIncrement')) return;
      if(Object.keys(data).indexOf(schemaKey) &lt; 0) return;
      incrementSequences.push(schemaKey);
    });

    // Run Query
    client.query(query.query, query.values, function __CREATE__(err, result) {
      if(err) return cb(handleQueryError(err));

      // Cast special values
      var values = processor.cast(tableName, result.rows[0]);

      // Set Sequence value to defined value if needed
      if(incrementSequences.length === 0) return cb(null, values);

      function setSequence(item, next) {
        var sequenceName = "'\"" + schemaName + '\".\"' + tableName + '_' + item + '_seq' + "\"'";
        var sequenceValue = values[item];
        var sequenceQuery = 'SELECT setval(' + sequenceName + ', ' + sequenceValue + ', true)';

        client.query(sequenceQuery, function(err, result) {
          if(err) return next(err);
          next();
        });
      }

      async.each(incrementSequences, setSequence, function(err) {
        if(err) return cb(err);
        cb(null, values);
      });

    });

  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sails-postgresql.createEach" id="apidoc.element.sails-postgresql.createEach">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>createEach
        <span class="apidocSignatureSpan">(connectionName, table, records, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createEach = function (connectionName, table, records, cb) {

  // Don't bother if there are no records to create.
  if (records.length === 0) {
    return cb();
  }

  spawnConnection(connectionName, function __CREATE_EACH__(client, cb) {

    var connectionObject = connections[connectionName];
    var collection = getCollection(connectionName, table);
    var tableName = table;
    var schemaName = getSchema(collection);

    // Build up a SQL Query
    var schema = connectionObject.schema;
    var processor = new Processor(schema);

    // Mixin WL Next connection overrides to sqlOptions
    var overrides = connectionOverrides[connectionName] || {};
    var options = _.cloneDeep(sqlOptions);
    if(hop(overrides, 'wlNext')) {
      options.wlNext = overrides.wlNext;
    }

    var sequel = new Sequel(schema, options);
    var incrementSequences = [];

    // Loop through all the attributes being inserted and check if a sequence was used
    Object.keys(collection.schema).forEach(function(schemaKey) {
      if(!utils.object.hasOwnProperty(collection.schema[schemaKey], 'autoIncrement')) return;
      incrementSequences.push({
        key: schemaKey,
        value: 0
      });
    });

    // Collect Query Results
    var results = [];

    // Simple way for now, in the future make this more awesome
    async.each(records, function(data, cb) {

      var query;

      // Build a query for the specific query strategy
      try {
        query = sequel.create(tableName, data);
      } catch(e) {
        return cb(e);
      }

      // Run Query
      client.query(query.query, query.values, function __CREATE_EACH__(err, result) {
        if(err) return cb(handleQueryError(err));

        // Cast special values
        var values = processor.cast(tableName, result.rows[0]);

        results.push(values);
        if(incrementSequences.length === 0) return cb(null, values);

        function checkSequence(item, next) {
          var currentValue  = item.value;
          var sequenceValue = values[item.key];

          if(currentValue &lt; sequenceValue) {
            item.value = sequenceValue;
          }
          next();
        }

        async.each(incrementSequences, checkSequence, function(err) {
          if(err) return cb(err);
          cb(null, values);
        });
      });

    }, function(err) {
      if(err) return cb(err);
      if(incrementSequences.length === 0) return cb(null, results);

      function setSequence(item, next) {
        if (sequenceValue === 0) {return next();}
        var sequenceName = "'\"" + schemaName + '\".\"' + tableName + '_' + item.key + '_seq' + "\"'";
        var sequenceValue = item.value;
        var sequenceQuery = 'SELECT setval(' + sequenceName + ', ' + sequenceValue + ', true)';

        client.query(sequenceQuery, function(err, result) {
          if(err) return next(err);
          next();
        });
      }

      async.each(incrementSequences, setSequence, function(err) {
        if(err) return cb(err);
        cb(null, results);
      });
    });

  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sails-postgresql.createSchema" id="apidoc.element.sails-postgresql.createSchema">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>createSchema
        <span class="apidocSignatureSpan">(connectionName, table, schemaName, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createSchema = function (connectionName, table, schemaName, cb) {

  if ('function' == typeof schemaName) {
    cb = schemaName;
    schemaName = getSchema(connectionName, table);
  }
  if (!schemaName) {
    throw new Error("No schemaName specified, and could not determined schemaname for table `" + table + "`");
  }

  // Build Query
  var query = 'CREATE SCHEMA "' + schemaName + '"';

  spawnConnection(connectionName, function (client, cb) {
    // Run Query
    client.query(query, function (err, result) {
      // If we get a "duplicate schema" error, just silently ignore it
      if (err &amp;&amp; err.code == '42P06') {return cb();}
      // If we get any other type of error, return it
      if (err) {
        err.type = 'CREATING_SCHEMA';
        err.schemaName = schemaName;
        return cb(err);
      }
      // It we get no error, we're all good.
      return cb();
    });
  }, cb);

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sails-postgresql.define" id="apidoc.element.sails-postgresql.define">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>define
        <span class="apidocSignatureSpan">(connectionName, table, definition, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">define = function (connectionName, table, definition, cb) {

  // Create a describe method to run after the define.
  // Ensures the define connection is properly closed.
  var describe = function(err, result) {
    if(err) return cb(err);

    // Describe (sets schema)
    adapter.describe(connectionName, table.replace(/["']/g, ""), cb);
  };

  var connectionObject = connections[connectionName];

  spawnConnection(connectionName, function __DEFINE__(client, cb) {

    // Get the schema name if any
    var schemaName = getSchema(connectionName, table);

    // If we're being told NOT to create schemas, then skip right to
    // creating the table.
    if (connectionObject.config.createSchemas === false) {return _define();}

    // If the schema name is "public", just finish creating the table
    if (schemaName == 'public') {return _define();}

    // If not, attempt to create the schema first.  This will succeed if
    // the schema already exists.
    adapter.createSchema(connectionName, table, schemaName, _define);

    function _define(errCreatingSchema) {

      if (errCreatingSchema) {
        cb(handleQueryError(errCreatingSchema));
      }

      // Escape Table Name
      var tableName = utils.escapeName(table, schemaName);

      // Iterate through each attribute, building a query string
      var _schema = utils.buildSchema(definition);

      // Check for any Index attributes
      var indexes = utils.buildIndexes(definition);

      // Build Query
      var query = 'CREATE TABLE ' + tableName + ' (' + _schema + ')';

      // Run Query
      client.query(query, function __DEFINE__(err, result) {

        if(err) {
          if (err.code == '3F000') {
            err.table = table;
            err.schemaName = schemaName;
          }
          return cb(handleQueryError(err));
        }

        // Build Indexes
        function buildIndex(name, cb) {

          // Strip slashes from table name, used to namespace index
          var cleanTable = table.replace(/['"]/g, '');

          // Build a query to create a namespaced index tableName_key
          var query = 'CREATE INDEX ' + utils.escapeName(cleanTable + '_' + name) + ' on ' + tableName + ' (' + utils.escapeName
(name) + ');';
          // Run Query
          client.query(query, function(err, result) {
            if(err) return cb(handleQueryError(err));
            cb();
          });
        }

        // Build indexes in series
        async.eachSeries(indexes, buildIndex, cb);
      });

    }

  }, describe);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sails-postgresql.describe" id="apidoc.element.sails-postgresql.describe">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>describe
        <span class="apidocSignatureSpan">(connectionName, table, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">describe = function (connectionName, table, cb) {
  spawnConnection(connectionName, function __DESCRIBE__(client, cb) {

    var connectionObject = connections[connectionName];
    var collection = connectionObject.collections[table];
    var tableName = table;
    var schemaName = getSchema(connectionName, table);

    // Build query to get a bunch of info from the information_schema
    // It's not super important to understand it only that it returns the following fields:
    // [Table, #, Column, Type, Null, Constraint, C, consrc, F Key, Default]
    var query = "SELECT x.nspname || '.' || x.relname as \"Table\", x.attnum as \"#\", x.attname as \"Column\", x.\"Type\"," +
      " case x.attnotnull when true then 'NOT NULL' else '' end as \"NULL\", r.conname as \"Constraint\", r.contype as \"C\", " +
      "r.consrc, fn.nspname || '.' || f.relname as \"F Key\", d.adsrc as \"Default\" FROM (" +
      "SELECT c.oid, a.attrelid, a.attnum, n.nspname, c.relname, a.attname, pg_catalog.format_type(a.atttypid, a.atttypmod) as \"
Type\", " +
      "a.attnotnull FROM pg_catalog.pg_attribute a, pg_namespace n, pg_class c WHERE a.attnum &gt; 0 AND NOT a.attisdropped AND a.attrelid
 = c.oid " +
      "and c.relkind not in ('S','v') and c.relnamespace = n.oid and n.nspname not in ('pg_catalog','pg_toast','information_schema
')) x " +
      "left join pg_attrdef d on d.adrelid = x.attrelid and d.adnum = x.attnum " +
      "left join pg_constraint r on r.conrelid = x.oid and r.conkey[1] = x.attnum " +
      "left join pg_class f on r.confrelid = f.oid " +
      "left join pg_namespace fn on f.relnamespace = fn.oid " +
      "where x.relname = '" + tableName + "' and x.nspname = '" + schemaName + "' order by 1,2;";

    // Get Sequences to test if column auto-increments
    var autoIncrementQuery = "SELECT t.relname as related_table, a.attname as related_column, s.relname as sequence_name " +
      "FROM pg_class s JOIN pg_depend d ON d.objid = s.oid JOIN pg_class t ON d.objid = s.oid AND d.refobjid = t.oid " +
      "JOIN pg_attribute a ON (d.refobjid, d.refobjsubid) = (a.attrelid, a.attnum) JOIN pg_namespace n ON n.oid = s.relnamespace
 " +
      "WHERE s.relkind = 'S' AND n.nspname = '" + schemaName + "';";

    // Get Indexes
    var indiciesQuery = "SELECT n.nspname as \"Schema\", c.relname as \"Name\", CASE c.relkind WHEN 'r' THEN 'table' " +
      "WHEN 'v' THEN 'view' WHEN 'i' THEN 'index' WHEN 'S' THEN 'sequence' WHEN 's' THEN 'special' WHEN 'f' THEN " +
      "'foreign table' END as \"Type\", pg_catalog.pg_get_userbyid(c.relowner) as \"Owner\", c2.relname as \"Table\" " +
      "FROM pg_catalog.pg_class c LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace " +
      "LEFT JOIN pg_catalog.pg_index i ON i.indexrelid = c.oid " +
      "LEFT JOIN pg_catalog.pg_class c2 ON i.indrelid = c2.oid " +
      "WHERE c.relkind IN ('i','') AND n.nspname &lt;&gt; 'pg_catalog' AND n.nspname &lt;&gt; 'information_schema' " +
      "AND n.nspname !~ '^pg_toast' AND pg_catalog.pg_table_is_visible(c.oid) ORDER BY 1,2;";

    // Run Info Query
    client.query(query, function(err, result) {
      if(err) return cb(handleQueryError(err));
      if(result.rows.length === 0) return cb();

      // Run Query to get Auto Incrementing sequences
      client.query(autoIncrementQuery, function(err, aResult) {
        if(err) return cb(handleQueryError(err));

        aResult.rows.forEach(function(row) {
          if(row.related_table !== table) return;

          // Look through query results and see if related_column exists
          result.rows.forEach(function(column) {
            if(column.Column !== row.related_column) return;
            column.autoIncrement = true;
          });
        });

        // Run Query to get Indexed values
        client.query(indiciesQuery, function(err, iResult) {
          if(err) return cb(handleQueryError(err));

          // Loop through indicies and see if any match
          iResult.rows.forEach(function(column) {
            var key = column.Name.split('_index_')[1];

            // Look through query results and see if key e ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sails-postgresql.destroy" id="apidoc.element.sails-postgresql.destroy">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>destroy
        <span class="apidocSignatureSpan">(connectionName, table, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destroy = function (connectionName, table, options, cb) {
  spawnConnection(connectionName, function __DELETE__(client, cb) {

    var connectionObject = connections[connectionName];
    var collection = connectionObject.collections[table];
    var tableName = table;

    var _schema = connectionObject.schema;

    // Mixin WL Next connection overrides to sqlOptions
    var overrides = connectionOverrides[connectionName] || {};
    var _options = _.cloneDeep(sqlOptions);
    if(hop(overrides, 'wlNext')) {
      _options.wlNext = overrides.wlNext;
    }

    var sequel = new Sequel(_schema, _options);
    var query;

    // Build a query for the specific query strategy
    try {
      query = sequel.destroy(tableName, options);
    } catch(e) {
      return cb(e);
    }

    // Run Query
    client.query(query.query, query.values, function __DELETE__(err, result) {
      if(err) return cb(handleQueryError(err));
      cb(null, result.rows);
    });

  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sails-postgresql.drop" id="apidoc.element.sails-postgresql.drop">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>drop
        <span class="apidocSignatureSpan">(connectionName, table, relations, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">drop = function (connectionName, table, relations, cb) {

  if(typeof relations === 'function') {
    cb = relations;
    relations = [];
  }

  spawnConnection(connectionName, function __DROP__(client, cb) {

    // Drop any relations
    function dropTable(item, next) {

      var tableName = utils.escapeName(item, getSchema(connectionName, item));

      // Build Query
      var query = 'DROP TABLE ' + tableName + ';';

      // Run Query
      client.query(query, function __DROP__(err, result) {
        if(err) result = null;
        next(null, result);
      });
    }

    async.eachSeries(relations, dropTable, function(err) {
      if(err) return cb(err);
      dropTable(table, cb);
    });

  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sails-postgresql.find" id="apidoc.element.sails-postgresql.find">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>find
        <span class="apidocSignatureSpan">(connectionName, table, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">find = function (connectionName, table, options, cb) {
  spawnConnection(connectionName, function __FIND__(client, cb) {

    // Grab Connection Schema
    var schema = {};
    var connectionObject = connections[connectionName];
    var collection = connectionObject.collections[table];
    var tableName = table;

    Object.keys(connectionObject.collections).forEach(function(coll) {
      schema[coll] = connectionObject.collections[coll].schema;
    });

    // Build Query
    var _schema = connectionObject.schema;
    var processor = new Processor(_schema);

    // Mixin WL Next connection overrides to sqlOptions
    var overrides = connectionOverrides[connectionName] || {};
    var _options = _.cloneDeep(sqlOptions);
    if(hop(overrides, 'wlNext')) {
      _options.wlNext = overrides.wlNext;
    }

    var sequel = new Sequel(_schema, _options);
    var _query;

    // Build a query for the specific query strategy
    try {
      _query = sequel.find(tableName, options);
    } catch(e) {
      return cb(e);
    }
    client.query(_query.query[0], _query.values[0], function __FIND__(err, result) {
      if(err) return cb(handleQueryError(err));

      // Cast special values
      var values = [];

      result.rows.forEach(function(row) {
        values.push(processor.cast(tableName, row));
      });

      return cb(null, values);
    });

  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sails-postgresql.join" id="apidoc.element.sails-postgresql.join">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>join
        <span class="apidocSignatureSpan">(connectionName, table, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">join = function (connectionName, table, options, cb) {

  spawnConnection(connectionName, function __FIND__(client, done) {

    // Populate associated records for each parent result
    // (or do them all at once as an optimization, if possible)
    Cursor({

      instructions: options,
      nativeJoins: true,

<span class="apidocCodeCommentSpan">      /**
       * Find some records directly (using only this adapter)
       * from the specified collection.
       *
       * @param  {String}   collectionIdentity
       * @param  {Object}   criteria
       * @param  {Function} _cb
       */
</span>      $find: function (collectionName, criteria, _cb) {
        return adapter.find(conn, collectionIdentity, criteria, _cb, client);
      },

      /**
       * Look up the name of the primary key field
       * for the collection with the specified identity.
       *
       * @param  {String}   collectionIdentity
       * @return {String}
       */
      $getPK: function (collectionName) {
        if (!collectionName) return;
        return _getPK(connectionName, collectionName);
      },

      /**
       * Given a strategy type, build up and execute a SQL query for it.
       *
       * @param {}
       */

      $populateBuffers: function populateBuffers(options, next) {

        var buffers = options.buffers;
        var instructions = options.instructions;

        // Grab the collection by looking into the connection
        var connectionObject = connections[connectionName];
        var collection = connectionObject.collections[table];
        var tableName = table;

        var parentRecords = [];
        var cachedChildren = {};

        // Grab Connection Schema
        var schema = {};

        Object.keys(connectionObject.collections).forEach(function(coll) {
          schema[coll] = connectionObject.collections[coll].schema;
        });

        // Build Query
        var _schema = connectionObject.schema;

        // Mixin WL Next connection overrides to sqlOptions
        var overrides = connectionOverrides[connectionName] || {};
        var _options = _.cloneDeep(sqlOptions);
        if(hop(overrides, 'wlNext')) {
          _options.wlNext = overrides.wlNext;
        }

        var sequel = new Sequel(_schema, _options);
        var _query;

        // Build a query for the specific query strategy
        try {
          _query = sequel.find(tableName, instructions);
        } catch(e) {
          return next(e);
        }

        async.auto({

          processParent: function(next) {

            client.query(_query.query[0], _query.values[0], function __FIND__(err, result) {
              if(err) return next(handleQueryError(err));

              parentRecords = result.rows;

              var splitChildren = function(parent, next) {
                var cache = {};

                _.keys(parent).forEach(function(key) {

                  // Check if we can split this on our special alias identifier '___' and if
                  // so put the result in the cache
                  var split = key.split('___');
                  if(split.length &lt; 2) return;

                  if(!hop(cache, split[0])) cache[split[0]] = {};
                  cache[split[0]][split[1]] = parent[key];
                  delete parent[key];
                });

                // Combine the local cache into the cachedChildren
                if(_.keys(cache).length &gt; 0) {
                  _.keys(cache).forEach(function(pop) {
                    if(!hop(cachedChildren, pop)) cachedChildren[pop] = [];
                    cachedChildren[pop] = cachedChildren[pop].concat(cache[pop]);
                  });
                }

                next();
              };


              // Pull out any aliased child records that have come from a hasFK association
              async.eachSeries(parentRecords, splitChildren, function(err) {
                if(err) return next(err);
                buffers.parents = parentRecords;
                next();
              });
            });
          },

          // Build child buffers.
          // For each instruction, loop through the p ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    attribute.type = val;
  }

  var type = utils.sqlTypeCast(attribute.autoIncrement ? 'SERIAL' : attribute.type);
  var nullable = attribute.notNull &amp;&amp; 'NOT NULL';
  var unique = attribute.unique &amp;&amp; 'UNIQUE';

  return _.compact([ '"' + name + '"', type, nullable, unique ]).<span class="apidocCodeKeywordSpan
">join</span>(' ');
}).join(',');

var primaryKeys = _.keys(_.pick(obj, function (attribute) {
  return attribute.primaryKey;
}));

var constraints = _.compact([
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sails-postgresql.processor" id="apidoc.element.sails-postgresql.processor">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>processor
        <span class="apidocSignatureSpan">(schema)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Processor(schema) {
  this.schema = _.cloneDeep(schema);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sails-postgresql.query" id="apidoc.element.sails-postgresql.query">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>query
        <span class="apidocSignatureSpan">(connectionName, table, query, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">query = function (connectionName, table, query, data, cb) {

  if (_.isFunction(data)) {
    cb = data;
    data = null;
  }

  spawnConnection(connectionName, function __QUERY__(client, cb) {

    // Run query
    if (data) client.query(query, data, cb);
    else client.query(query, cb);

  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sails-postgresql.registerConnection" id="apidoc.element.sails-postgresql.registerConnection">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>registerConnection
        <span class="apidocSignatureSpan">(connection, collections, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerConnection = function (connection, collections, cb) {

  var self = this;

  if(!connection.identity) return cb(Errors.IdentityMissing);
  if(connections[connection.identity]) return cb(Errors.IdentityDuplicate);

  // Store any connection overrides
  connectionOverrides[connection.identity] = {};

  // Look for the WL Next key
  if(hop(connection, 'wlNext')) {
    connectionOverrides[connection.identity].wlNext = _.cloneDeep(connection.wlNext);
  }

  // Build up a schema for this connection that can be used throughout the adapter
  var schema = {};

  _.each(_.keys(collections), function(coll) {
    var collection = collections[coll];
    if(!collection) return;

    var _schema = collection.waterline &amp;&amp; collection.waterline.schema &amp;&amp; collection.waterline.schema[collection.identity];
    if(!_schema) return;

    // Set defaults to ensure values are set
    if(!_schema.attributes) _schema.attributes = {};
    if(!_schema.tableName) _schema.tableName = coll;

    // If the connection names are't the same we don't need it in the schema
    if(!_.includes(collections[coll].connection, connection.identity)) {
      return;
    }

    // If this collection has a schema name set, make sure that it's passed
    // through to the options for waterline-sequel.
    if(hop(collection, 'meta') &amp;&amp; hop(collection.meta, 'schemaName')) {
      sqlOptions.schemaName[_schema.tableName] = collection.meta.schemaName;
    } else {
      sqlOptions.schemaName[_schema.tableName] = "public";
    }

    // If the tableName is different from the identity, store the tableName in the schema
    var schemaKey = coll;
    if(_schema.tableName != coll) {
      schemaKey = _schema.tableName;
    }

    schema[schemaKey] = _schema;
  });

  // Store the connection
  connections[connection.identity] = {
    config: connection,
    collections: collections,
    schema: schema
  };

  // Always call describe
  async.map(Object.keys(collections), function(colName, cb){
    self.describe(connection.identity, colName, cb);
  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sails-postgresql.removeAttribute" id="apidoc.element.sails-postgresql.removeAttribute">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>removeAttribute
        <span class="apidocSignatureSpan">(connectionName, table, attrName, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeAttribute = function (connectionName, table, attrName, cb) {
  spawnConnection(connectionName, function __REMOVE_ATTRIBUTE__(client, cb) {

    // Escape Table Name
    table = utils.escapeName(table, getSchema(connectionName, table));

    // Build Query
    var query = 'ALTER TABLE ' + table + ' DROP COLUMN "' + attrName + '" RESTRICT';

    // Run Query
    client.query(query, function __REMOVE_ATTRIBUTE__(err, result) {
      if(err) return cb(handleQueryError(err));
      cb(null, result.rows);
    });

  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sails-postgresql.stream" id="apidoc.element.sails-postgresql.stream">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>stream
        <span class="apidocSignatureSpan">(connectionName, table, options, stream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stream = function (connectionName, table, options, stream) {

  var connectionObject = connections[connectionName];
  var collection = connectionObject.collections[table];

  var client = new pg.Client(connectionObject.config);
  client.connect();

  var schema = {};

  Object.keys(connectionObject.collections).forEach(function(coll) {
    schema[coll] = connectionObject.collections[coll].schema;
  });

  // Build Query
  var _schema = collection.schema;
  var queryObj = new Query(_schema, schema);
  var query =queryObj.find(table, options);

  // Run Query
  var dbStream = client.query(query.query, query.values);

  //can stream row results back 1 at a time
  dbStream.on('row', function(row) {
    stream.write(row);
  });

  dbStream.on('error', function(err) {
    stream.end(); // End stream
    client.end(); // Close Connection
  });

  //fired after last row is emitted
  dbStream.on('end', function() {
    stream.end(); // End stream
    client.end(); // Close Connection
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sails-postgresql.teardown" id="apidoc.element.sails-postgresql.teardown">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>teardown
        <span class="apidocSignatureSpan">(conn, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">teardown = function (conn, cb) {
  if (typeof conn == 'function') {
    cb = conn;
    conn = null;
  }
  if (conn === null) {
    connections = {};
    return cb();
  }
  if(!connections[conn]) return cb();
  delete connections[conn];
  cb();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sails-postgresql.update" id="apidoc.element.sails-postgresql.update">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>update
        <span class="apidocSignatureSpan">(connectionName, table, options, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">update = function (connectionName, table, options, data, cb) {
  //LIMIT in a postgresql UPDATE command is not valid
  if (hop(options, 'limit')) {
    return cb(new Error('Your \'LIMIT ' + options.limit + '\' is not allowed in the PostgreSQL UPDATE query.'));
  }
  spawnConnection(connectionName, function __UPDATE__(client, cb) {

    var connectionObject = connections[connectionName];
    var collection = connectionObject.collections[table];
    var tableName = table;

    var _schema = connectionObject.schema;
    var processor = new Processor(_schema);

    // Mixin WL Next connection overrides to sqlOptions
    var overrides = connectionOverrides[connectionName] || {};
    var _options = _.cloneDeep(sqlOptions);
    if(hop(overrides, 'wlNext')) {
      _options.wlNext = overrides.wlNext;
    }

    var sequel = new Sequel(_schema, _options);
    var query;

    // Build a query for the specific query strategy
    try {
      query = sequel.update(tableName, options, data);
    } catch(e) {
      return cb(e);
    }

    // Run Query
    client.query(query.query, query.values, function __UPDATE__(err, result) {
      if(err) return cb(handleQueryError(err));

      // Cast special values
      var values = [];

      result.rows.forEach(function(row) {
        values.push(processor.cast(tableName, row));
      });

      cb(null, values);
    });

  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>












</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sails-postgresql.addAttribute" id="apidoc.module.sails-postgresql.addAttribute">module sails-postgresql.addAttribute</a></h1>


    <h2>
        <a href="#apidoc.element.sails-postgresql.addAttribute.addAttribute" id="apidoc.element.sails-postgresql.addAttribute.addAttribute">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>addAttribute
        <span class="apidocSignatureSpan">(connectionName, table, attrName, attrDef, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addAttribute = function (connectionName, table, attrName, attrDef, cb) {
  spawnConnection(connectionName, function __ADD_ATTRIBUTE__(client, cb) {

    // Escape Table Name
    table = utils.escapeName(table, getSchema(connectionName, table));

    // Setup a Schema Definition
    var attrs = {};
    attrs[attrName] = attrDef;

    var _schema = utils.buildSchema(attrs);

    // Build Query
    var query = 'ALTER TABLE ' + table + ' ADD COLUMN ' + _schema;

    // Run Query
    client.query(query, function __ADD_ATTRIBUTE__(err, result) {
      if(err) return cb(handleQueryError(err));
      cb(null, result.rows);
    });

  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sails-postgresql.count" id="apidoc.module.sails-postgresql.count">module sails-postgresql.count</a></h1>


    <h2>
        <a href="#apidoc.element.sails-postgresql.count.count" id="apidoc.element.sails-postgresql.count.count">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>count
        <span class="apidocSignatureSpan">(connectionName, table, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">count = function (connectionName, table, options, cb) {
  spawnConnection(connectionName, function __COUNT__(client, cb) {

    // Grab Connection Schema
    var schema = {};
    var connectionObject = connections[connectionName];
    var collection = connectionObject.collections[table];
    var tableName = table;

    Object.keys(connectionObject.collections).forEach(function(coll) {
      schema[coll] = connectionObject.collections[coll].schema;
    });

    // Build Query
    var _schema = connectionObject.schema;
    var processor = new Processor(_schema);

    // Mixin WL Next connection overrides to sqlOptions
    var overrides = connectionOverrides[connectionName] || {};
    var _options = _.cloneDeep(sqlOptions);
    if(hop(overrides, 'wlNext')) {
      _options.wlNext = overrides.wlNext;
    }

    var sequel = new Sequel(_schema, _options);
    var _query;

    // Build a query for the specific query strategy
    try {
      _query = sequel.count(tableName, options);
    } catch(e) {
      return cb(e);
    }

    client.query(_query.query[0], _query.values[0], function __COUNT__(err, result) {
      if(err) return cb(handleQueryError(err));
      if(!_.isArray(result.rows) || !result.rows.length) {
        return cb(new Error('Invalid query, no results returned.'));
      }

      var count = result.rows[0] &amp;&amp; result.rows[0].count;
      return cb(null, Number(count));
    });

  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sails-postgresql.create" id="apidoc.module.sails-postgresql.create">module sails-postgresql.create</a></h1>


    <h2>
        <a href="#apidoc.element.sails-postgresql.create.create" id="apidoc.element.sails-postgresql.create.create">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>create
        <span class="apidocSignatureSpan">(connectionName, table, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (connectionName, table, data, cb) {
  spawnConnection(connectionName, function __CREATE__(client, cb) {

    var connectionObject = connections[connectionName];
    var collection = getCollection(connectionName, table);
    var tableName = table;
    var schemaName = getSchema(collection);

    // Build up a SQL Query
    var schema = connectionObject.schema;
    var processor = new Processor(schema);

    // Mixin WL Next connection overrides to sqlOptions
    var overrides = connectionOverrides[connectionName] || {};
    var options = _.cloneDeep(sqlOptions);
    if(hop(overrides, 'wlNext')) {
      options.wlNext = overrides.wlNext;
    }

    var sequel = new Sequel(schema, options);

    var incrementSequences = [];
    var query;

    // Build a query for the specific query strategy
    try {
      query = sequel.create(table, data);
    } catch(e) {
      return cb(e);
    }

    // Loop through all the attributes being inserted and check if a sequence was used
    Object.keys(collection.schema).forEach(function(schemaKey) {
      if(!utils.object.hasOwnProperty(collection.schema[schemaKey], 'autoIncrement')) return;
      if(Object.keys(data).indexOf(schemaKey) &lt; 0) return;
      incrementSequences.push(schemaKey);
    });

    // Run Query
    client.query(query.query, query.values, function __CREATE__(err, result) {
      if(err) return cb(handleQueryError(err));

      // Cast special values
      var values = processor.cast(tableName, result.rows[0]);

      // Set Sequence value to defined value if needed
      if(incrementSequences.length === 0) return cb(null, values);

      function setSequence(item, next) {
        var sequenceName = "'\"" + schemaName + '\".\"' + tableName + '_' + item + '_seq' + "\"'";
        var sequenceValue = values[item];
        var sequenceQuery = 'SELECT setval(' + sequenceName + ', ' + sequenceValue + ', true)';

        client.query(sequenceQuery, function(err, result) {
          if(err) return next(err);
          next();
        });
      }

      async.each(incrementSequences, setSequence, function(err) {
        if(err) return cb(err);
        cb(null, values);
      });

    });

  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sails-postgresql.createEach" id="apidoc.module.sails-postgresql.createEach">module sails-postgresql.createEach</a></h1>


    <h2>
        <a href="#apidoc.element.sails-postgresql.createEach.createEach" id="apidoc.element.sails-postgresql.createEach.createEach">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>createEach
        <span class="apidocSignatureSpan">(connectionName, table, records, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createEach = function (connectionName, table, records, cb) {

  // Don't bother if there are no records to create.
  if (records.length === 0) {
    return cb();
  }

  spawnConnection(connectionName, function __CREATE_EACH__(client, cb) {

    var connectionObject = connections[connectionName];
    var collection = getCollection(connectionName, table);
    var tableName = table;
    var schemaName = getSchema(collection);

    // Build up a SQL Query
    var schema = connectionObject.schema;
    var processor = new Processor(schema);

    // Mixin WL Next connection overrides to sqlOptions
    var overrides = connectionOverrides[connectionName] || {};
    var options = _.cloneDeep(sqlOptions);
    if(hop(overrides, 'wlNext')) {
      options.wlNext = overrides.wlNext;
    }

    var sequel = new Sequel(schema, options);
    var incrementSequences = [];

    // Loop through all the attributes being inserted and check if a sequence was used
    Object.keys(collection.schema).forEach(function(schemaKey) {
      if(!utils.object.hasOwnProperty(collection.schema[schemaKey], 'autoIncrement')) return;
      incrementSequences.push({
        key: schemaKey,
        value: 0
      });
    });

    // Collect Query Results
    var results = [];

    // Simple way for now, in the future make this more awesome
    async.each(records, function(data, cb) {

      var query;

      // Build a query for the specific query strategy
      try {
        query = sequel.create(tableName, data);
      } catch(e) {
        return cb(e);
      }

      // Run Query
      client.query(query.query, query.values, function __CREATE_EACH__(err, result) {
        if(err) return cb(handleQueryError(err));

        // Cast special values
        var values = processor.cast(tableName, result.rows[0]);

        results.push(values);
        if(incrementSequences.length === 0) return cb(null, values);

        function checkSequence(item, next) {
          var currentValue  = item.value;
          var sequenceValue = values[item.key];

          if(currentValue &lt; sequenceValue) {
            item.value = sequenceValue;
          }
          next();
        }

        async.each(incrementSequences, checkSequence, function(err) {
          if(err) return cb(err);
          cb(null, values);
        });
      });

    }, function(err) {
      if(err) return cb(err);
      if(incrementSequences.length === 0) return cb(null, results);

      function setSequence(item, next) {
        if (sequenceValue === 0) {return next();}
        var sequenceName = "'\"" + schemaName + '\".\"' + tableName + '_' + item.key + '_seq' + "\"'";
        var sequenceValue = item.value;
        var sequenceQuery = 'SELECT setval(' + sequenceName + ', ' + sequenceValue + ', true)';

        client.query(sequenceQuery, function(err, result) {
          if(err) return next(err);
          next();
        });
      }

      async.each(incrementSequences, setSequence, function(err) {
        if(err) return cb(err);
        cb(null, results);
      });
    });

  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sails-postgresql.createSchema" id="apidoc.module.sails-postgresql.createSchema">module sails-postgresql.createSchema</a></h1>


    <h2>
        <a href="#apidoc.element.sails-postgresql.createSchema.createSchema" id="apidoc.element.sails-postgresql.createSchema.createSchema">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>createSchema
        <span class="apidocSignatureSpan">(connectionName, table, schemaName, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createSchema = function (connectionName, table, schemaName, cb) {

  if ('function' == typeof schemaName) {
    cb = schemaName;
    schemaName = getSchema(connectionName, table);
  }
  if (!schemaName) {
    throw new Error("No schemaName specified, and could not determined schemaname for table `" + table + "`");
  }

  // Build Query
  var query = 'CREATE SCHEMA "' + schemaName + '"';

  spawnConnection(connectionName, function (client, cb) {
    // Run Query
    client.query(query, function (err, result) {
      // If we get a "duplicate schema" error, just silently ignore it
      if (err &amp;&amp; err.code == '42P06') {return cb();}
      // If we get any other type of error, return it
      if (err) {
        err.type = 'CREATING_SCHEMA';
        err.schemaName = schemaName;
        return cb(err);
      }
      // It we get no error, we're all good.
      return cb();
    });
  }, cb);

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sails-postgresql.define" id="apidoc.module.sails-postgresql.define">module sails-postgresql.define</a></h1>


    <h2>
        <a href="#apidoc.element.sails-postgresql.define.define" id="apidoc.element.sails-postgresql.define.define">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>define
        <span class="apidocSignatureSpan">(connectionName, table, definition, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">define = function (connectionName, table, definition, cb) {

  // Create a describe method to run after the define.
  // Ensures the define connection is properly closed.
  var describe = function(err, result) {
    if(err) return cb(err);

    // Describe (sets schema)
    adapter.describe(connectionName, table.replace(/["']/g, ""), cb);
  };

  var connectionObject = connections[connectionName];

  spawnConnection(connectionName, function __DEFINE__(client, cb) {

    // Get the schema name if any
    var schemaName = getSchema(connectionName, table);

    // If we're being told NOT to create schemas, then skip right to
    // creating the table.
    if (connectionObject.config.createSchemas === false) {return _define();}

    // If the schema name is "public", just finish creating the table
    if (schemaName == 'public') {return _define();}

    // If not, attempt to create the schema first.  This will succeed if
    // the schema already exists.
    adapter.createSchema(connectionName, table, schemaName, _define);

    function _define(errCreatingSchema) {

      if (errCreatingSchema) {
        cb(handleQueryError(errCreatingSchema));
      }

      // Escape Table Name
      var tableName = utils.escapeName(table, schemaName);

      // Iterate through each attribute, building a query string
      var _schema = utils.buildSchema(definition);

      // Check for any Index attributes
      var indexes = utils.buildIndexes(definition);

      // Build Query
      var query = 'CREATE TABLE ' + tableName + ' (' + _schema + ')';

      // Run Query
      client.query(query, function __DEFINE__(err, result) {

        if(err) {
          if (err.code == '3F000') {
            err.table = table;
            err.schemaName = schemaName;
          }
          return cb(handleQueryError(err));
        }

        // Build Indexes
        function buildIndex(name, cb) {

          // Strip slashes from table name, used to namespace index
          var cleanTable = table.replace(/['"]/g, '');

          // Build a query to create a namespaced index tableName_key
          var query = 'CREATE INDEX ' + utils.escapeName(cleanTable + '_' + name) + ' on ' + tableName + ' (' + utils.escapeName
(name) + ');';
          // Run Query
          client.query(query, function(err, result) {
            if(err) return cb(handleQueryError(err));
            cb();
          });
        }

        // Build indexes in series
        async.eachSeries(indexes, buildIndex, cb);
      });

    }

  }, describe);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sails-postgresql.describe" id="apidoc.module.sails-postgresql.describe">module sails-postgresql.describe</a></h1>


    <h2>
        <a href="#apidoc.element.sails-postgresql.describe.describe" id="apidoc.element.sails-postgresql.describe.describe">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>describe
        <span class="apidocSignatureSpan">(connectionName, table, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">describe = function (connectionName, table, cb) {
  spawnConnection(connectionName, function __DESCRIBE__(client, cb) {

    var connectionObject = connections[connectionName];
    var collection = connectionObject.collections[table];
    var tableName = table;
    var schemaName = getSchema(connectionName, table);

    // Build query to get a bunch of info from the information_schema
    // It's not super important to understand it only that it returns the following fields:
    // [Table, #, Column, Type, Null, Constraint, C, consrc, F Key, Default]
    var query = "SELECT x.nspname || '.' || x.relname as \"Table\", x.attnum as \"#\", x.attname as \"Column\", x.\"Type\"," +
      " case x.attnotnull when true then 'NOT NULL' else '' end as \"NULL\", r.conname as \"Constraint\", r.contype as \"C\", " +
      "r.consrc, fn.nspname || '.' || f.relname as \"F Key\", d.adsrc as \"Default\" FROM (" +
      "SELECT c.oid, a.attrelid, a.attnum, n.nspname, c.relname, a.attname, pg_catalog.format_type(a.atttypid, a.atttypmod) as \"
Type\", " +
      "a.attnotnull FROM pg_catalog.pg_attribute a, pg_namespace n, pg_class c WHERE a.attnum &gt; 0 AND NOT a.attisdropped AND a.attrelid
 = c.oid " +
      "and c.relkind not in ('S','v') and c.relnamespace = n.oid and n.nspname not in ('pg_catalog','pg_toast','information_schema
')) x " +
      "left join pg_attrdef d on d.adrelid = x.attrelid and d.adnum = x.attnum " +
      "left join pg_constraint r on r.conrelid = x.oid and r.conkey[1] = x.attnum " +
      "left join pg_class f on r.confrelid = f.oid " +
      "left join pg_namespace fn on f.relnamespace = fn.oid " +
      "where x.relname = '" + tableName + "' and x.nspname = '" + schemaName + "' order by 1,2;";

    // Get Sequences to test if column auto-increments
    var autoIncrementQuery = "SELECT t.relname as related_table, a.attname as related_column, s.relname as sequence_name " +
      "FROM pg_class s JOIN pg_depend d ON d.objid = s.oid JOIN pg_class t ON d.objid = s.oid AND d.refobjid = t.oid " +
      "JOIN pg_attribute a ON (d.refobjid, d.refobjsubid) = (a.attrelid, a.attnum) JOIN pg_namespace n ON n.oid = s.relnamespace
 " +
      "WHERE s.relkind = 'S' AND n.nspname = '" + schemaName + "';";

    // Get Indexes
    var indiciesQuery = "SELECT n.nspname as \"Schema\", c.relname as \"Name\", CASE c.relkind WHEN 'r' THEN 'table' " +
      "WHEN 'v' THEN 'view' WHEN 'i' THEN 'index' WHEN 'S' THEN 'sequence' WHEN 's' THEN 'special' WHEN 'f' THEN " +
      "'foreign table' END as \"Type\", pg_catalog.pg_get_userbyid(c.relowner) as \"Owner\", c2.relname as \"Table\" " +
      "FROM pg_catalog.pg_class c LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace " +
      "LEFT JOIN pg_catalog.pg_index i ON i.indexrelid = c.oid " +
      "LEFT JOIN pg_catalog.pg_class c2 ON i.indrelid = c2.oid " +
      "WHERE c.relkind IN ('i','') AND n.nspname &lt;&gt; 'pg_catalog' AND n.nspname &lt;&gt; 'information_schema' " +
      "AND n.nspname !~ '^pg_toast' AND pg_catalog.pg_table_is_visible(c.oid) ORDER BY 1,2;";

    // Run Info Query
    client.query(query, function(err, result) {
      if(err) return cb(handleQueryError(err));
      if(result.rows.length === 0) return cb();

      // Run Query to get Auto Incrementing sequences
      client.query(autoIncrementQuery, function(err, aResult) {
        if(err) return cb(handleQueryError(err));

        aResult.rows.forEach(function(row) {
          if(row.related_table !== table) return;

          // Look through query results and see if related_column exists
          result.rows.forEach(function(column) {
            if(column.Column !== row.related_column) return;
            column.autoIncrement = true;
          });
        });

        // Run Query to get Indexed values
        client.query(indiciesQuery, function(err, iResult) {
          if(err) return cb(handleQueryError(err));

          // Loop through indicies and see if any match
          iResult.rows.forEach(function(column) {
            var key = column.Name.split('_index_')[1];

            // Look through query results and see if key e ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sails-postgresql.destroy" id="apidoc.module.sails-postgresql.destroy">module sails-postgresql.destroy</a></h1>


    <h2>
        <a href="#apidoc.element.sails-postgresql.destroy.destroy" id="apidoc.element.sails-postgresql.destroy.destroy">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>destroy
        <span class="apidocSignatureSpan">(connectionName, table, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destroy = function (connectionName, table, options, cb) {
  spawnConnection(connectionName, function __DELETE__(client, cb) {

    var connectionObject = connections[connectionName];
    var collection = connectionObject.collections[table];
    var tableName = table;

    var _schema = connectionObject.schema;

    // Mixin WL Next connection overrides to sqlOptions
    var overrides = connectionOverrides[connectionName] || {};
    var _options = _.cloneDeep(sqlOptions);
    if(hop(overrides, 'wlNext')) {
      _options.wlNext = overrides.wlNext;
    }

    var sequel = new Sequel(_schema, _options);
    var query;

    // Build a query for the specific query strategy
    try {
      query = sequel.destroy(tableName, options);
    } catch(e) {
      return cb(e);
    }

    // Run Query
    client.query(query.query, query.values, function __DELETE__(err, result) {
      if(err) return cb(handleQueryError(err));
      cb(null, result.rows);
    });

  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sails-postgresql.drop" id="apidoc.module.sails-postgresql.drop">module sails-postgresql.drop</a></h1>


    <h2>
        <a href="#apidoc.element.sails-postgresql.drop.drop" id="apidoc.element.sails-postgresql.drop.drop">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>drop
        <span class="apidocSignatureSpan">(connectionName, table, relations, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">drop = function (connectionName, table, relations, cb) {

  if(typeof relations === 'function') {
    cb = relations;
    relations = [];
  }

  spawnConnection(connectionName, function __DROP__(client, cb) {

    // Drop any relations
    function dropTable(item, next) {

      var tableName = utils.escapeName(item, getSchema(connectionName, item));

      // Build Query
      var query = 'DROP TABLE ' + tableName + ';';

      // Run Query
      client.query(query, function __DROP__(err, result) {
        if(err) result = null;
        next(null, result);
      });
    }

    async.eachSeries(relations, dropTable, function(err) {
      if(err) return cb(err);
      dropTable(table, cb);
    });

  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sails-postgresql.find" id="apidoc.module.sails-postgresql.find">module sails-postgresql.find</a></h1>


    <h2>
        <a href="#apidoc.element.sails-postgresql.find.find" id="apidoc.element.sails-postgresql.find.find">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>find
        <span class="apidocSignatureSpan">(connectionName, table, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">find = function (connectionName, table, options, cb) {
  spawnConnection(connectionName, function __FIND__(client, cb) {

    // Grab Connection Schema
    var schema = {};
    var connectionObject = connections[connectionName];
    var collection = connectionObject.collections[table];
    var tableName = table;

    Object.keys(connectionObject.collections).forEach(function(coll) {
      schema[coll] = connectionObject.collections[coll].schema;
    });

    // Build Query
    var _schema = connectionObject.schema;
    var processor = new Processor(_schema);

    // Mixin WL Next connection overrides to sqlOptions
    var overrides = connectionOverrides[connectionName] || {};
    var _options = _.cloneDeep(sqlOptions);
    if(hop(overrides, 'wlNext')) {
      _options.wlNext = overrides.wlNext;
    }

    var sequel = new Sequel(_schema, _options);
    var _query;

    // Build a query for the specific query strategy
    try {
      _query = sequel.find(tableName, options);
    } catch(e) {
      return cb(e);
    }
    client.query(_query.query[0], _query.values[0], function __FIND__(err, result) {
      if(err) return cb(handleQueryError(err));

      // Cast special values
      var values = [];

      result.rows.forEach(function(row) {
        values.push(processor.cast(tableName, row));
      });

      return cb(null, values);
    });

  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sails-postgresql.join" id="apidoc.module.sails-postgresql.join">module sails-postgresql.join</a></h1>


    <h2>
        <a href="#apidoc.element.sails-postgresql.join.join" id="apidoc.element.sails-postgresql.join.join">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>join
        <span class="apidocSignatureSpan">(connectionName, table, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">join = function (connectionName, table, options, cb) {

  spawnConnection(connectionName, function __FIND__(client, done) {

    // Populate associated records for each parent result
    // (or do them all at once as an optimization, if possible)
    Cursor({

      instructions: options,
      nativeJoins: true,

<span class="apidocCodeCommentSpan">      /**
       * Find some records directly (using only this adapter)
       * from the specified collection.
       *
       * @param  {String}   collectionIdentity
       * @param  {Object}   criteria
       * @param  {Function} _cb
       */
</span>      $find: function (collectionName, criteria, _cb) {
        return adapter.find(conn, collectionIdentity, criteria, _cb, client);
      },

      /**
       * Look up the name of the primary key field
       * for the collection with the specified identity.
       *
       * @param  {String}   collectionIdentity
       * @return {String}
       */
      $getPK: function (collectionName) {
        if (!collectionName) return;
        return _getPK(connectionName, collectionName);
      },

      /**
       * Given a strategy type, build up and execute a SQL query for it.
       *
       * @param {}
       */

      $populateBuffers: function populateBuffers(options, next) {

        var buffers = options.buffers;
        var instructions = options.instructions;

        // Grab the collection by looking into the connection
        var connectionObject = connections[connectionName];
        var collection = connectionObject.collections[table];
        var tableName = table;

        var parentRecords = [];
        var cachedChildren = {};

        // Grab Connection Schema
        var schema = {};

        Object.keys(connectionObject.collections).forEach(function(coll) {
          schema[coll] = connectionObject.collections[coll].schema;
        });

        // Build Query
        var _schema = connectionObject.schema;

        // Mixin WL Next connection overrides to sqlOptions
        var overrides = connectionOverrides[connectionName] || {};
        var _options = _.cloneDeep(sqlOptions);
        if(hop(overrides, 'wlNext')) {
          _options.wlNext = overrides.wlNext;
        }

        var sequel = new Sequel(_schema, _options);
        var _query;

        // Build a query for the specific query strategy
        try {
          _query = sequel.find(tableName, instructions);
        } catch(e) {
          return next(e);
        }

        async.auto({

          processParent: function(next) {

            client.query(_query.query[0], _query.values[0], function __FIND__(err, result) {
              if(err) return next(handleQueryError(err));

              parentRecords = result.rows;

              var splitChildren = function(parent, next) {
                var cache = {};

                _.keys(parent).forEach(function(key) {

                  // Check if we can split this on our special alias identifier '___' and if
                  // so put the result in the cache
                  var split = key.split('___');
                  if(split.length &lt; 2) return;

                  if(!hop(cache, split[0])) cache[split[0]] = {};
                  cache[split[0]][split[1]] = parent[key];
                  delete parent[key];
                });

                // Combine the local cache into the cachedChildren
                if(_.keys(cache).length &gt; 0) {
                  _.keys(cache).forEach(function(pop) {
                    if(!hop(cachedChildren, pop)) cachedChildren[pop] = [];
                    cachedChildren[pop] = cachedChildren[pop].concat(cache[pop]);
                  });
                }

                next();
              };


              // Pull out any aliased child records that have come from a hasFK association
              async.eachSeries(parentRecords, splitChildren, function(err) {
                if(err) return next(err);
                buffers.parents = parentRecords;
                next();
              });
            });
          },

          // Build child buffers.
          // For each instruction, loop through the p ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    attribute.type = val;
  }

  var type = utils.sqlTypeCast(attribute.autoIncrement ? 'SERIAL' : attribute.type);
  var nullable = attribute.notNull &amp;&amp; 'NOT NULL';
  var unique = attribute.unique &amp;&amp; 'UNIQUE';

  return _.compact([ '"' + name + '"', type, nullable, unique ]).<span class="apidocCodeKeywordSpan
">join</span>(' ');
}).join(',');

var primaryKeys = _.keys(_.pick(obj, function (attribute) {
  return attribute.primaryKey;
}));

var constraints = _.compact([
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sails-postgresql.processor" id="apidoc.module.sails-postgresql.processor">module sails-postgresql.processor</a></h1>


    <h2>
        <a href="#apidoc.element.sails-postgresql.processor.processor" id="apidoc.element.sails-postgresql.processor.processor">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>processor
        <span class="apidocSignatureSpan">(schema)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Processor(schema) {
  this.schema = _.cloneDeep(schema);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sails-postgresql.processor.prototype" id="apidoc.module.sails-postgresql.processor.prototype">module sails-postgresql.processor.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.sails-postgresql.processor.prototype.cast" id="apidoc.element.sails-postgresql.processor.prototype.cast">
        function <span class="apidocSignatureSpan">sails-postgresql.processor.prototype.</span>cast
        <span class="apidocSignatureSpan">(table, values)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cast = function (table, values) {

  var self = this;
  var _values = _.cloneDeep(values);

  Object.keys(values).forEach(function(key) {
    self.castValue(table, key, _values[key], _values);
  });

  return _values;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sails-postgresql.processor.prototype.castValue" id="apidoc.element.sails-postgresql.processor.prototype.castValue">
        function <span class="apidocSignatureSpan">sails-postgresql.processor.prototype.</span>castValue
        <span class="apidocSignatureSpan">(table, key, value, attributes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">castValue = function (table, key, value, attributes) {

  var self = this;
  var identity = table;
  var attr;

  // Check for a columnName, serialize so we can do any casting
  Object.keys(this.schema[identity].attributes).forEach(function(attribute) {
    if(self.schema[identity].attributes[attribute].columnName === key) {
      attr = attribute;
      return;
    }
  });

  if(!attr) attr = key;

  // Lookup Schema "Type"
  if(!this.schema[identity] || !this.schema[identity].attributes[attr]) return;
  var type;

  if(!_.isPlainObject(this.schema[identity].attributes[attr])) {
    type = this.schema[identity].attributes[attr];
  } else {
    type = this.schema[identity].attributes[attr].type;
  }


  if(!type) return;

  // Attempt to parse Array
  if(type === 'array') {
    try {
      attributes[key] = JSON.parse(value);
    } catch(e) {
      return;
    }
  }

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Processor.prototype.cast = function(table, values) {

 var self = this;
 var _values = _.cloneDeep(values);

 Object.keys(values).forEach(function(key) {
   self.<span class="apidocCodeKeywordSpan">castValue</span>(table, key, _values[key], _values);
 });

 return _values;
};

/**
* Cast a value
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sails-postgresql.query" id="apidoc.module.sails-postgresql.query">module sails-postgresql.query</a></h1>


    <h2>
        <a href="#apidoc.element.sails-postgresql.query.query" id="apidoc.element.sails-postgresql.query.query">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>query
        <span class="apidocSignatureSpan">(connectionName, table, query, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">query = function (connectionName, table, query, data, cb) {

  if (_.isFunction(data)) {
    cb = data;
    data = null;
  }

  spawnConnection(connectionName, function __QUERY__(client, cb) {

    // Run query
    if (data) client.query(query, data, cb);
    else client.query(query, cb);

  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sails-postgresql.registerConnection" id="apidoc.module.sails-postgresql.registerConnection">module sails-postgresql.registerConnection</a></h1>


    <h2>
        <a href="#apidoc.element.sails-postgresql.registerConnection.registerConnection" id="apidoc.element.sails-postgresql.registerConnection.registerConnection">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>registerConnection
        <span class="apidocSignatureSpan">(connection, collections, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerConnection = function (connection, collections, cb) {

  var self = this;

  if(!connection.identity) return cb(Errors.IdentityMissing);
  if(connections[connection.identity]) return cb(Errors.IdentityDuplicate);

  // Store any connection overrides
  connectionOverrides[connection.identity] = {};

  // Look for the WL Next key
  if(hop(connection, 'wlNext')) {
    connectionOverrides[connection.identity].wlNext = _.cloneDeep(connection.wlNext);
  }

  // Build up a schema for this connection that can be used throughout the adapter
  var schema = {};

  _.each(_.keys(collections), function(coll) {
    var collection = collections[coll];
    if(!collection) return;

    var _schema = collection.waterline &amp;&amp; collection.waterline.schema &amp;&amp; collection.waterline.schema[collection.identity];
    if(!_schema) return;

    // Set defaults to ensure values are set
    if(!_schema.attributes) _schema.attributes = {};
    if(!_schema.tableName) _schema.tableName = coll;

    // If the connection names are't the same we don't need it in the schema
    if(!_.includes(collections[coll].connection, connection.identity)) {
      return;
    }

    // If this collection has a schema name set, make sure that it's passed
    // through to the options for waterline-sequel.
    if(hop(collection, 'meta') &amp;&amp; hop(collection.meta, 'schemaName')) {
      sqlOptions.schemaName[_schema.tableName] = collection.meta.schemaName;
    } else {
      sqlOptions.schemaName[_schema.tableName] = "public";
    }

    // If the tableName is different from the identity, store the tableName in the schema
    var schemaKey = coll;
    if(_schema.tableName != coll) {
      schemaKey = _schema.tableName;
    }

    schema[schemaKey] = _schema;
  });

  // Store the connection
  connections[connection.identity] = {
    config: connection,
    collections: collections,
    schema: schema
  };

  // Always call describe
  async.map(Object.keys(collections), function(colName, cb){
    self.describe(connection.identity, colName, cb);
  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sails-postgresql.removeAttribute" id="apidoc.module.sails-postgresql.removeAttribute">module sails-postgresql.removeAttribute</a></h1>


    <h2>
        <a href="#apidoc.element.sails-postgresql.removeAttribute.removeAttribute" id="apidoc.element.sails-postgresql.removeAttribute.removeAttribute">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>removeAttribute
        <span class="apidocSignatureSpan">(connectionName, table, attrName, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeAttribute = function (connectionName, table, attrName, cb) {
  spawnConnection(connectionName, function __REMOVE_ATTRIBUTE__(client, cb) {

    // Escape Table Name
    table = utils.escapeName(table, getSchema(connectionName, table));

    // Build Query
    var query = 'ALTER TABLE ' + table + ' DROP COLUMN "' + attrName + '" RESTRICT';

    // Run Query
    client.query(query, function __REMOVE_ATTRIBUTE__(err, result) {
      if(err) return cb(handleQueryError(err));
      cb(null, result.rows);
    });

  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sails-postgresql.stream" id="apidoc.module.sails-postgresql.stream">module sails-postgresql.stream</a></h1>


    <h2>
        <a href="#apidoc.element.sails-postgresql.stream.stream" id="apidoc.element.sails-postgresql.stream.stream">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>stream
        <span class="apidocSignatureSpan">(connectionName, table, options, stream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stream = function (connectionName, table, options, stream) {

  var connectionObject = connections[connectionName];
  var collection = connectionObject.collections[table];

  var client = new pg.Client(connectionObject.config);
  client.connect();

  var schema = {};

  Object.keys(connectionObject.collections).forEach(function(coll) {
    schema[coll] = connectionObject.collections[coll].schema;
  });

  // Build Query
  var _schema = collection.schema;
  var queryObj = new Query(_schema, schema);
  var query =queryObj.find(table, options);

  // Run Query
  var dbStream = client.query(query.query, query.values);

  //can stream row results back 1 at a time
  dbStream.on('row', function(row) {
    stream.write(row);
  });

  dbStream.on('error', function(err) {
    stream.end(); // End stream
    client.end(); // Close Connection
  });

  //fired after last row is emitted
  dbStream.on('end', function() {
    stream.end(); // End stream
    client.end(); // Close Connection
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sails-postgresql.teardown" id="apidoc.module.sails-postgresql.teardown">module sails-postgresql.teardown</a></h1>


    <h2>
        <a href="#apidoc.element.sails-postgresql.teardown.teardown" id="apidoc.element.sails-postgresql.teardown.teardown">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>teardown
        <span class="apidocSignatureSpan">(conn, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">teardown = function (conn, cb) {
  if (typeof conn == 'function') {
    cb = conn;
    conn = null;
  }
  if (conn === null) {
    connections = {};
    return cb();
  }
  if(!connections[conn]) return cb();
  delete connections[conn];
  cb();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sails-postgresql.update" id="apidoc.module.sails-postgresql.update">module sails-postgresql.update</a></h1>


    <h2>
        <a href="#apidoc.element.sails-postgresql.update.update" id="apidoc.element.sails-postgresql.update.update">
        function <span class="apidocSignatureSpan">sails-postgresql.</span>update
        <span class="apidocSignatureSpan">(connectionName, table, options, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">update = function (connectionName, table, options, data, cb) {
  //LIMIT in a postgresql UPDATE command is not valid
  if (hop(options, 'limit')) {
    return cb(new Error('Your \'LIMIT ' + options.limit + '\' is not allowed in the PostgreSQL UPDATE query.'));
  }
  spawnConnection(connectionName, function __UPDATE__(client, cb) {

    var connectionObject = connections[connectionName];
    var collection = connectionObject.collections[table];
    var tableName = table;

    var _schema = connectionObject.schema;
    var processor = new Processor(_schema);

    // Mixin WL Next connection overrides to sqlOptions
    var overrides = connectionOverrides[connectionName] || {};
    var _options = _.cloneDeep(sqlOptions);
    if(hop(overrides, 'wlNext')) {
      _options.wlNext = overrides.wlNext;
    }

    var sequel = new Sequel(_schema, _options);
    var query;

    // Build a query for the specific query strategy
    try {
      query = sequel.update(tableName, options, data);
    } catch(e) {
      return cb(e);
    }

    // Run Query
    client.query(query.query, query.values, function __UPDATE__(err, result) {
      if(err) return cb(handleQueryError(err));

      // Cast special values
      var values = [];

      result.rows.forEach(function(row) {
        values.push(processor.cast(tableName, row));
      });

      cb(null, values);
    });

  }, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sails-postgresql.utils" id="apidoc.module.sails-postgresql.utils">module sails-postgresql.utils</a></h1>


    <h2>
        <a href="#apidoc.element.sails-postgresql.utils.buildIndexes" id="apidoc.element.sails-postgresql.utils.buildIndexes">
        function <span class="apidocSignatureSpan">sails-postgresql.utils.</span>buildIndexes
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildIndexes = function (obj) {
  var indexes = [];

  // Iterate through the Object keys and pull out any index attributes
  Object.keys(obj).forEach(function(key) {
    if(obj[key].hasOwnProperty('index')) {
      indexes.push(key);
    }
  });

  return indexes;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sails-postgresql.utils.buildSchema" id="apidoc.element.sails-postgresql.utils.buildSchema">
        function <span class="apidocSignatureSpan">sails-postgresql.utils.</span>buildSchema
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildSchema = function (obj) {
  var columns = _.map(obj, function (attribute, name) {
    if (_.isString(attribute)) {
      var val = attribute;
      attribute = {};
      attribute.type = val;
    }

    var type = utils.sqlTypeCast(attribute.autoIncrement ? 'SERIAL' : attribute.type);
    var nullable = attribute.notNull &amp;&amp; 'NOT NULL';
    var unique = attribute.unique &amp;&amp; 'UNIQUE';

    return _.compact([ '"' + name + '"', type, nullable, unique ]).join(' ');
  }).join(',');

  var primaryKeys = _.keys(_.pick(obj, function (attribute) {
    return attribute.primaryKey;
  }));

  var constraints = _.compact([
    primaryKeys.length &amp;&amp; 'PRIMARY KEY ("' + primaryKeys.join('","') + '")'
  ]).join(', ');

  return _.compact([ columns, constraints ]).join(', ');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sails-postgresql.utils.escapeName" id="apidoc.element.sails-postgresql.utils.escapeName">
        function <span class="apidocSignatureSpan">sails-postgresql.utils.</span>escapeName
        <span class="apidocSignatureSpan">(name, schema)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function escapeName(name, schema) {
  name = '"' + name + '"';
  if (schema) {
    name = '"' + schema + '".' + name;
  }
  return name;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sails-postgresql.utils.mapAttributes" id="apidoc.element.sails-postgresql.utils.mapAttributes">
        function <span class="apidocSignatureSpan">sails-postgresql.utils.</span>mapAttributes
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mapAttributes = function (data) {
  var keys = [],   // Column Names
      values = [], // Column Values
      params = [], // Param Index, ex: $1, $2
      i = 1;

  Object.keys(data).forEach(function(key) {
    keys.push('"' + key + '"');
    values.push(utils.prepareValue(data[key]));
    params.push('$' + i);
    i++;
  });

  return({ keys: keys, values: values, params: params });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sails-postgresql.utils.marshalConfig" id="apidoc.element.sails-postgresql.utils.marshalConfig">
        function <span class="apidocSignatureSpan">sails-postgresql.utils.</span>marshalConfig
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">marshalConfig = function (config) {
  return _.extend(config, {
    host: config.host,
    user: config.user,
    password: config.password,
    database: config.database,
    port: config.port
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sails-postgresql.utils.normalizeSchema" id="apidoc.element.sails-postgresql.utils.normalizeSchema">
        function <span class="apidocSignatureSpan">sails-postgresql.utils.</span>normalizeSchema
        <span class="apidocSignatureSpan">(schema)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">normalizeSchema = function (schema) {
  var normalized = {};
  var clone = _.clone(schema);

  clone.forEach(function(column) {

    // Set Type
    normalized[column.Column] = {
      type: column.Type
    };

    // Check for Primary Key
    if(column.Constraint &amp;&amp; column.C === 'p') {
      normalized[column.Column].primaryKey = true;
    }

    // Check for Unique Constraint
    if(column.Constraint &amp;&amp; column.C === 'u') {
      normalized[column.Column].unique = true;
    }

    // Check for autoIncrement
    if(column.autoIncrement) {
      normalized[column.Column].autoIncrement = column.autoIncrement;
    }

    // Check for index
    if(column.indexed) {
      normalized[column.Column].indexed = column.indexed;
    }

  });

  return normalized;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sails-postgresql.utils.prepareValue" id="apidoc.element.sails-postgresql.utils.prepareValue">
        function <span class="apidocSignatureSpan">sails-postgresql.utils.</span>prepareValue
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prepareValue = function (value) {

  // Cast dates to SQL
  if (_.isDate(value)) {
    value = utils.toSqlDate(value);
  }

  // Cast functions to strings
  if (_.isFunction(value)) {
    value = value.toString();
  }

  // Store Arrays as strings
  if (Array.isArray(value)) {
    value = JSON.stringify(value);
  }

  // Store Buffers as hex strings (for BYTEA)
  if (Buffer.isBuffer(value)) {
    value = '\\x' + value.toString('hex');
  }

  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var keys = [],   // Column Names
      values = [], // Column Values
      params = [], // Param Index, ex: $1, $2
      i = 1;

  Object.keys(data).forEach(function(key) {
    keys.push('"' + key + '"');
    values.push(utils.<span class="apidocCodeKeywordSpan">prepareValue</span>(data[key]));
    params.push('$' + i);
    i++;
  });

  return({ keys: keys, values: values, params: params });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sails-postgresql.utils.sqlTypeCast" id="apidoc.element.sails-postgresql.utils.sqlTypeCast">
        function <span class="apidocSignatureSpan">sails-postgresql.utils.</span>sqlTypeCast
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sqlTypeCast = function (type) {
  switch (type.toLowerCase()) {
    case 'serial':
      return 'SERIAL';
    case 'smallserial':
      return 'SMALLSERIAL';
    case 'bigserial':
      return 'BIGSERIAL';

    case 'string':
    case 'text':
    case 'mediumtext':
    case 'longtext':
      return 'TEXT';

    case 'boolean':
      return 'BOOLEAN';

    case 'int':
    case 'integer':
      return 'INT';

    case 'smallint':
      return 'SMALLINT';
    case 'bigint':
      return 'BIGINT';
    case 'real':
    case 'float':
      return 'REAL';
    case 'double':
      return 'DOUBLE PRECISION';
    case 'decimal':
      return 'DECIMAL';

    // Store all time with the time zone
    case 'time':
        return 'TIME WITH TIME ZONE';
    // Store all dates as timestamps with the time zone
    case 'date':
      return 'DATE';
    case 'datestamp':
    case 'datetime':
      return 'TIMESTAMP WITH TIME ZONE';

    case 'array':
      return 'TEXT';

    case 'json':
      return 'JSON';

    case 'binary':
    case 'bytea':
      return 'BYTEA';

    default:
      console.error("Unregistered type given: " + type);
      return "TEXT";
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var columns = _.map(obj, function (attribute, name) {
  if (_.isString(attribute)) {
    var val = attribute;
    attribute = {};
    attribute.type = val;
  }

  var type = utils.<span class="apidocCodeKeywordSpan">sqlTypeCast</span>(attribute.autoIncrement ? 'SERIAL' : attribute
.type);
  var nullable = attribute.notNull &amp;&amp; 'NOT NULL';
  var unique = attribute.unique &amp;&amp; 'UNIQUE';

  return _.compact([ '"' + name + '"', type, nullable, unique ]).join(' ');
}).join(',');

var primaryKeys = _.keys(_.pick(obj, function (attribute) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sails-postgresql.utils.toSqlDate" id="apidoc.element.sails-postgresql.utils.toSqlDate">
        function <span class="apidocSignatureSpan">sails-postgresql.utils.</span>toSqlDate
        <span class="apidocSignatureSpan">(date)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toSqlDate = function (date) {
  return date.toUTCString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * to strings.
 */

utils.prepareValue = function(value) {

// Cast dates to SQL
if (_.isDate(value)) {
  value = utils.<span class="apidocCodeKeywordSpan">toSqlDate</span>(value);
}

// Cast functions to strings
if (_.isFunction(value)) {
  value = value.toString();
}
...</pre></li>
    </ul>




</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>